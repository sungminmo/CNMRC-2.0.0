// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: polo.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "polo.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace polo {
namespace wire {
namespace protobuf {

void protobuf_ShutdownFile_polo_2eproto() {
  delete OuterMessage::default_instance_;
  delete PairingRequest::default_instance_;
  delete PairingRequestAck::default_instance_;
  delete Options::default_instance_;
  delete Options_Encoding::default_instance_;
  delete Configuration::default_instance_;
  delete ConfigurationAck::default_instance_;
  delete Secret::default_instance_;
  delete SecretAck::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_polo_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_polo_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  OuterMessage::default_instance_ = new OuterMessage();
  PairingRequest::default_instance_ = new PairingRequest();
  PairingRequestAck::default_instance_ = new PairingRequestAck();
  Options::default_instance_ = new Options();
  Options_Encoding::default_instance_ = new Options_Encoding();
  Configuration::default_instance_ = new Configuration();
  ConfigurationAck::default_instance_ = new ConfigurationAck();
  Secret::default_instance_ = new Secret();
  SecretAck::default_instance_ = new SecretAck();
  OuterMessage::default_instance_->InitAsDefaultInstance();
  PairingRequest::default_instance_->InitAsDefaultInstance();
  PairingRequestAck::default_instance_->InitAsDefaultInstance();
  Options::default_instance_->InitAsDefaultInstance();
  Options_Encoding::default_instance_->InitAsDefaultInstance();
  Configuration::default_instance_->InitAsDefaultInstance();
  ConfigurationAck::default_instance_->InitAsDefaultInstance();
  Secret::default_instance_->InitAsDefaultInstance();
  SecretAck::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_polo_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_polo_2eproto_once_);
void protobuf_AddDesc_polo_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_polo_2eproto_once_,
                 &protobuf_AddDesc_polo_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_polo_2eproto {
  StaticDescriptorInitializer_polo_2eproto() {
    protobuf_AddDesc_polo_2eproto();
  }
} static_descriptor_initializer_polo_2eproto_;
#endif

// ===================================================================

bool OuterMessage_MessageType_IsValid(int value) {
  switch(value) {
    case 10:
    case 11:
    case 20:
    case 30:
    case 31:
    case 40:
    case 41:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const OuterMessage_MessageType OuterMessage::MESSAGE_TYPE_PAIRING_REQUEST;
const OuterMessage_MessageType OuterMessage::MESSAGE_TYPE_PAIRING_REQUEST_ACK;
const OuterMessage_MessageType OuterMessage::MESSAGE_TYPE_OPTIONS;
const OuterMessage_MessageType OuterMessage::MESSAGE_TYPE_CONFIGURATION;
const OuterMessage_MessageType OuterMessage::MESSAGE_TYPE_CONFIGURATION_ACK;
const OuterMessage_MessageType OuterMessage::MESSAGE_TYPE_SECRET;
const OuterMessage_MessageType OuterMessage::MESSAGE_TYPE_SECRET_ACK;
const OuterMessage_MessageType OuterMessage::MessageType_MIN;
const OuterMessage_MessageType OuterMessage::MessageType_MAX;
const int OuterMessage::MessageType_ARRAYSIZE;
#endif  // _MSC_VER
bool OuterMessage_Status_IsValid(int value) {
  switch(value) {
    case 200:
    case 400:
    case 401:
    case 402:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const OuterMessage_Status OuterMessage::STATUS_OK;
const OuterMessage_Status OuterMessage::STATUS_ERROR;
const OuterMessage_Status OuterMessage::STATUS_BAD_CONFIGURATION;
const OuterMessage_Status OuterMessage::STATUS_BAD_SECRET;
const OuterMessage_Status OuterMessage::Status_MIN;
const OuterMessage_Status OuterMessage::Status_MAX;
const int OuterMessage::Status_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int OuterMessage::kProtocolVersionFieldNumber;
const int OuterMessage::kStatusFieldNumber;
const int OuterMessage::kTypeFieldNumber;
const int OuterMessage::kPayloadFieldNumber;
#endif  // !_MSC_VER

OuterMessage::OuterMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:polo.wire.protobuf.OuterMessage)
}

void OuterMessage::InitAsDefaultInstance() {
}

OuterMessage::OuterMessage(const OuterMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:polo.wire.protobuf.OuterMessage)
}

void OuterMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  protocol_version_ = 1u;
  status_ = 200;
  type_ = 10;
  payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OuterMessage::~OuterMessage() {
  // @@protoc_insertion_point(destructor:polo.wire.protobuf.OuterMessage)
  SharedDtor();
}

void OuterMessage::SharedDtor() {
  if (payload_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete payload_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void OuterMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OuterMessage& OuterMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_polo_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_polo_2eproto();
#endif
  return *default_instance_;
}

OuterMessage* OuterMessage::default_instance_ = NULL;

OuterMessage* OuterMessage::New() const {
  return new OuterMessage;
}

void OuterMessage::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    protocol_version_ = 1u;
    status_ = 200;
    type_ = 10;
    if (has_payload()) {
      if (payload_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        payload_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool OuterMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:polo.wire.protobuf.OuterMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 protocol_version = 1 [default = 1];
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &protocol_version_)));
          set_has_protocol_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_status;
        break;
      }

      // required .polo.wire.protobuf.OuterMessage.Status status = 2;
      case 2: {
        if (tag == 16) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::polo::wire::protobuf::OuterMessage_Status_IsValid(value)) {
            set_status(static_cast< ::polo::wire::protobuf::OuterMessage_Status >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // optional .polo.wire.protobuf.OuterMessage.MessageType type = 3;
      case 3: {
        if (tag == 24) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::polo::wire::protobuf::OuterMessage_MessageType_IsValid(value)) {
            set_type(static_cast< ::polo::wire::protobuf::OuterMessage_MessageType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_payload;
        break;
      }

      // optional bytes payload = 4;
      case 4: {
        if (tag == 34) {
         parse_payload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:polo.wire.protobuf.OuterMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:polo.wire.protobuf.OuterMessage)
  return false;
#undef DO_
}

void OuterMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:polo.wire.protobuf.OuterMessage)
  // required uint32 protocol_version = 1 [default = 1];
  if (has_protocol_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->protocol_version(), output);
  }

  // required .polo.wire.protobuf.OuterMessage.Status status = 2;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->status(), output);
  }

  // optional .polo.wire.protobuf.OuterMessage.MessageType type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->type(), output);
  }

  // optional bytes payload = 4;
  if (has_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->payload(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:polo.wire.protobuf.OuterMessage)
}

int OuterMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 protocol_version = 1 [default = 1];
    if (has_protocol_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->protocol_version());
    }

    // required .polo.wire.protobuf.OuterMessage.Status status = 2;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // optional .polo.wire.protobuf.OuterMessage.MessageType type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional bytes payload = 4;
    if (has_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->payload());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OuterMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OuterMessage*>(&from));
}

void OuterMessage::MergeFrom(const OuterMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_protocol_version()) {
      set_protocol_version(from.protocol_version());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_payload()) {
      set_payload(from.payload());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void OuterMessage::CopyFrom(const OuterMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OuterMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void OuterMessage::Swap(OuterMessage* other) {
  if (other != this) {
    std::swap(protocol_version_, other->protocol_version_);
    std::swap(status_, other->status_);
    std::swap(type_, other->type_);
    std::swap(payload_, other->payload_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OuterMessage::GetTypeName() const {
  return "polo.wire.protobuf.OuterMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int PairingRequest::kServiceNameFieldNumber;
const int PairingRequest::kClientNameFieldNumber;
#endif  // !_MSC_VER

PairingRequest::PairingRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:polo.wire.protobuf.PairingRequest)
}

void PairingRequest::InitAsDefaultInstance() {
}

PairingRequest::PairingRequest(const PairingRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:polo.wire.protobuf.PairingRequest)
}

void PairingRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  service_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  client_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PairingRequest::~PairingRequest() {
  // @@protoc_insertion_point(destructor:polo.wire.protobuf.PairingRequest)
  SharedDtor();
}

void PairingRequest::SharedDtor() {
  if (service_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_name_;
  }
  if (client_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PairingRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PairingRequest& PairingRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_polo_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_polo_2eproto();
#endif
  return *default_instance_;
}

PairingRequest* PairingRequest::default_instance_ = NULL;

PairingRequest* PairingRequest::New() const {
  return new PairingRequest;
}

void PairingRequest::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_service_name()) {
      if (service_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        service_name_->clear();
      }
    }
    if (has_client_name()) {
      if (client_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        client_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PairingRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:polo.wire.protobuf.PairingRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string service_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_service_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_client_name;
        break;
      }

      // optional string client_name = 2;
      case 2: {
        if (tag == 18) {
         parse_client_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_client_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:polo.wire.protobuf.PairingRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:polo.wire.protobuf.PairingRequest)
  return false;
#undef DO_
}

void PairingRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:polo.wire.protobuf.PairingRequest)
  // required string service_name = 1;
  if (has_service_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->service_name(), output);
  }

  // optional string client_name = 2;
  if (has_client_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->client_name(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:polo.wire.protobuf.PairingRequest)
}

int PairingRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string service_name = 1;
    if (has_service_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->service_name());
    }

    // optional string client_name = 2;
    if (has_client_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->client_name());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PairingRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PairingRequest*>(&from));
}

void PairingRequest::MergeFrom(const PairingRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_service_name()) {
      set_service_name(from.service_name());
    }
    if (from.has_client_name()) {
      set_client_name(from.client_name());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PairingRequest::CopyFrom(const PairingRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PairingRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void PairingRequest::Swap(PairingRequest* other) {
  if (other != this) {
    std::swap(service_name_, other->service_name_);
    std::swap(client_name_, other->client_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PairingRequest::GetTypeName() const {
  return "polo.wire.protobuf.PairingRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int PairingRequestAck::kServerNameFieldNumber;
#endif  // !_MSC_VER

PairingRequestAck::PairingRequestAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:polo.wire.protobuf.PairingRequestAck)
}

void PairingRequestAck::InitAsDefaultInstance() {
}

PairingRequestAck::PairingRequestAck(const PairingRequestAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:polo.wire.protobuf.PairingRequestAck)
}

void PairingRequestAck::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PairingRequestAck::~PairingRequestAck() {
  // @@protoc_insertion_point(destructor:polo.wire.protobuf.PairingRequestAck)
  SharedDtor();
}

void PairingRequestAck::SharedDtor() {
  if (server_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete server_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PairingRequestAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PairingRequestAck& PairingRequestAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_polo_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_polo_2eproto();
#endif
  return *default_instance_;
}

PairingRequestAck* PairingRequestAck::default_instance_ = NULL;

PairingRequestAck* PairingRequestAck::New() const {
  return new PairingRequestAck;
}

void PairingRequestAck::Clear() {
  if (has_server_name()) {
    if (server_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      server_name_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PairingRequestAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:polo.wire.protobuf.PairingRequestAck)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string server_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_server_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:polo.wire.protobuf.PairingRequestAck)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:polo.wire.protobuf.PairingRequestAck)
  return false;
#undef DO_
}

void PairingRequestAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:polo.wire.protobuf.PairingRequestAck)
  // optional string server_name = 1;
  if (has_server_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->server_name(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:polo.wire.protobuf.PairingRequestAck)
}

int PairingRequestAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string server_name = 1;
    if (has_server_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->server_name());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PairingRequestAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PairingRequestAck*>(&from));
}

void PairingRequestAck::MergeFrom(const PairingRequestAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_server_name()) {
      set_server_name(from.server_name());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PairingRequestAck::CopyFrom(const PairingRequestAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PairingRequestAck::IsInitialized() const {

  return true;
}

void PairingRequestAck::Swap(PairingRequestAck* other) {
  if (other != this) {
    std::swap(server_name_, other->server_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PairingRequestAck::GetTypeName() const {
  return "polo.wire.protobuf.PairingRequestAck";
}


// ===================================================================

bool Options_RoleType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Options_RoleType Options::ROLE_TYPE_UNKNOWN;
const Options_RoleType Options::ROLE_TYPE_INPUT;
const Options_RoleType Options::ROLE_TYPE_OUTPUT;
const Options_RoleType Options::RoleType_MIN;
const Options_RoleType Options::RoleType_MAX;
const int Options::RoleType_ARRAYSIZE;
#endif  // _MSC_VER
bool Options_Encoding_EncodingType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Options_Encoding_EncodingType Options_Encoding::ENCODING_TYPE_UNKNOWN;
const Options_Encoding_EncodingType Options_Encoding::ENCODING_TYPE_ALPHANUMERIC;
const Options_Encoding_EncodingType Options_Encoding::ENCODING_TYPE_NUMERIC;
const Options_Encoding_EncodingType Options_Encoding::ENCODING_TYPE_HEXADECIMAL;
const Options_Encoding_EncodingType Options_Encoding::ENCODING_TYPE_QRCODE;
const Options_Encoding_EncodingType Options_Encoding::EncodingType_MIN;
const Options_Encoding_EncodingType Options_Encoding::EncodingType_MAX;
const int Options_Encoding::EncodingType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Options_Encoding::kTypeFieldNumber;
const int Options_Encoding::kSymbolLengthFieldNumber;
#endif  // !_MSC_VER

Options_Encoding::Options_Encoding()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:polo.wire.protobuf.Options.Encoding)
}

void Options_Encoding::InitAsDefaultInstance() {
}

Options_Encoding::Options_Encoding(const Options_Encoding& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:polo.wire.protobuf.Options.Encoding)
}

void Options_Encoding::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  symbol_length_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Options_Encoding::~Options_Encoding() {
  // @@protoc_insertion_point(destructor:polo.wire.protobuf.Options.Encoding)
  SharedDtor();
}

void Options_Encoding::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Options_Encoding::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Options_Encoding& Options_Encoding::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_polo_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_polo_2eproto();
#endif
  return *default_instance_;
}

Options_Encoding* Options_Encoding::default_instance_ = NULL;

Options_Encoding* Options_Encoding::New() const {
  return new Options_Encoding;
}

void Options_Encoding::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Options_Encoding*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(type_, symbol_length_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Options_Encoding::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:polo.wire.protobuf.Options.Encoding)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .polo.wire.protobuf.Options.Encoding.EncodingType type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::polo::wire::protobuf::Options_Encoding_EncodingType_IsValid(value)) {
            set_type(static_cast< ::polo::wire::protobuf::Options_Encoding_EncodingType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_symbol_length;
        break;
      }

      // required uint32 symbol_length = 2;
      case 2: {
        if (tag == 16) {
         parse_symbol_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &symbol_length_)));
          set_has_symbol_length();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:polo.wire.protobuf.Options.Encoding)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:polo.wire.protobuf.Options.Encoding)
  return false;
#undef DO_
}

void Options_Encoding::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:polo.wire.protobuf.Options.Encoding)
  // required .polo.wire.protobuf.Options.Encoding.EncodingType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // required uint32 symbol_length = 2;
  if (has_symbol_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->symbol_length(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:polo.wire.protobuf.Options.Encoding)
}

int Options_Encoding::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .polo.wire.protobuf.Options.Encoding.EncodingType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // required uint32 symbol_length = 2;
    if (has_symbol_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->symbol_length());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Options_Encoding::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Options_Encoding*>(&from));
}

void Options_Encoding::MergeFrom(const Options_Encoding& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_symbol_length()) {
      set_symbol_length(from.symbol_length());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Options_Encoding::CopyFrom(const Options_Encoding& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Options_Encoding::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Options_Encoding::Swap(Options_Encoding* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(symbol_length_, other->symbol_length_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Options_Encoding::GetTypeName() const {
  return "polo.wire.protobuf.Options.Encoding";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Options::kInputEncodingsFieldNumber;
const int Options::kOutputEncodingsFieldNumber;
const int Options::kPreferredRoleFieldNumber;
#endif  // !_MSC_VER

Options::Options()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:polo.wire.protobuf.Options)
}

void Options::InitAsDefaultInstance() {
}

Options::Options(const Options& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:polo.wire.protobuf.Options)
}

void Options::SharedCtor() {
  _cached_size_ = 0;
  preferred_role_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Options::~Options() {
  // @@protoc_insertion_point(destructor:polo.wire.protobuf.Options)
  SharedDtor();
}

void Options::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Options::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Options& Options::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_polo_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_polo_2eproto();
#endif
  return *default_instance_;
}

Options* Options::default_instance_ = NULL;

Options* Options::New() const {
  return new Options;
}

void Options::Clear() {
  preferred_role_ = 0;
  input_encodings_.Clear();
  output_encodings_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Options::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:polo.wire.protobuf.Options)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .polo.wire.protobuf.Options.Encoding input_encodings = 1;
      case 1: {
        if (tag == 10) {
         parse_input_encodings:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_input_encodings()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_input_encodings;
        if (input->ExpectTag(18)) goto parse_output_encodings;
        break;
      }

      // repeated .polo.wire.protobuf.Options.Encoding output_encodings = 2;
      case 2: {
        if (tag == 18) {
         parse_output_encodings:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_output_encodings()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_output_encodings;
        if (input->ExpectTag(24)) goto parse_preferred_role;
        break;
      }

      // optional .polo.wire.protobuf.Options.RoleType preferred_role = 3;
      case 3: {
        if (tag == 24) {
         parse_preferred_role:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::polo::wire::protobuf::Options_RoleType_IsValid(value)) {
            set_preferred_role(static_cast< ::polo::wire::protobuf::Options_RoleType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:polo.wire.protobuf.Options)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:polo.wire.protobuf.Options)
  return false;
#undef DO_
}

void Options::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:polo.wire.protobuf.Options)
  // repeated .polo.wire.protobuf.Options.Encoding input_encodings = 1;
  for (int i = 0; i < this->input_encodings_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->input_encodings(i), output);
  }

  // repeated .polo.wire.protobuf.Options.Encoding output_encodings = 2;
  for (int i = 0; i < this->output_encodings_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->output_encodings(i), output);
  }

  // optional .polo.wire.protobuf.Options.RoleType preferred_role = 3;
  if (has_preferred_role()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->preferred_role(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:polo.wire.protobuf.Options)
}

int Options::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    // optional .polo.wire.protobuf.Options.RoleType preferred_role = 3;
    if (has_preferred_role()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->preferred_role());
    }

  }
  // repeated .polo.wire.protobuf.Options.Encoding input_encodings = 1;
  total_size += 1 * this->input_encodings_size();
  for (int i = 0; i < this->input_encodings_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->input_encodings(i));
  }

  // repeated .polo.wire.protobuf.Options.Encoding output_encodings = 2;
  total_size += 1 * this->output_encodings_size();
  for (int i = 0; i < this->output_encodings_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->output_encodings(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Options::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Options*>(&from));
}

void Options::MergeFrom(const Options& from) {
  GOOGLE_CHECK_NE(&from, this);
  input_encodings_.MergeFrom(from.input_encodings_);
  output_encodings_.MergeFrom(from.output_encodings_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_preferred_role()) {
      set_preferred_role(from.preferred_role());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Options::CopyFrom(const Options& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Options::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->input_encodings())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->output_encodings())) return false;
  return true;
}

void Options::Swap(Options* other) {
  if (other != this) {
    input_encodings_.Swap(&other->input_encodings_);
    output_encodings_.Swap(&other->output_encodings_);
    std::swap(preferred_role_, other->preferred_role_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Options::GetTypeName() const {
  return "polo.wire.protobuf.Options";
}


// ===================================================================

#ifndef _MSC_VER
const int Configuration::kEncodingFieldNumber;
const int Configuration::kClientRoleFieldNumber;
#endif  // !_MSC_VER

Configuration::Configuration()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:polo.wire.protobuf.Configuration)
}

void Configuration::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  encoding_ = const_cast< ::polo::wire::protobuf::Options_Encoding*>(
      ::polo::wire::protobuf::Options_Encoding::internal_default_instance());
#else
  encoding_ = const_cast< ::polo::wire::protobuf::Options_Encoding*>(&::polo::wire::protobuf::Options_Encoding::default_instance());
#endif
}

Configuration::Configuration(const Configuration& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:polo.wire.protobuf.Configuration)
}

void Configuration::SharedCtor() {
  _cached_size_ = 0;
  encoding_ = NULL;
  client_role_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Configuration::~Configuration() {
  // @@protoc_insertion_point(destructor:polo.wire.protobuf.Configuration)
  SharedDtor();
}

void Configuration::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete encoding_;
  }
}

void Configuration::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Configuration& Configuration::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_polo_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_polo_2eproto();
#endif
  return *default_instance_;
}

Configuration* Configuration::default_instance_ = NULL;

Configuration* Configuration::New() const {
  return new Configuration;
}

void Configuration::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_encoding()) {
      if (encoding_ != NULL) encoding_->::polo::wire::protobuf::Options_Encoding::Clear();
    }
    client_role_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Configuration::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:polo.wire.protobuf.Configuration)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .polo.wire.protobuf.Options.Encoding encoding = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_encoding()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_client_role;
        break;
      }

      // required .polo.wire.protobuf.Options.RoleType client_role = 2;
      case 2: {
        if (tag == 16) {
         parse_client_role:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::polo::wire::protobuf::Options_RoleType_IsValid(value)) {
            set_client_role(static_cast< ::polo::wire::protobuf::Options_RoleType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:polo.wire.protobuf.Configuration)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:polo.wire.protobuf.Configuration)
  return false;
#undef DO_
}

void Configuration::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:polo.wire.protobuf.Configuration)
  // required .polo.wire.protobuf.Options.Encoding encoding = 1;
  if (has_encoding()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->encoding(), output);
  }

  // required .polo.wire.protobuf.Options.RoleType client_role = 2;
  if (has_client_role()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->client_role(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:polo.wire.protobuf.Configuration)
}

int Configuration::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .polo.wire.protobuf.Options.Encoding encoding = 1;
    if (has_encoding()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->encoding());
    }

    // required .polo.wire.protobuf.Options.RoleType client_role = 2;
    if (has_client_role()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->client_role());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Configuration::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Configuration*>(&from));
}

void Configuration::MergeFrom(const Configuration& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_encoding()) {
      mutable_encoding()->::polo::wire::protobuf::Options_Encoding::MergeFrom(from.encoding());
    }
    if (from.has_client_role()) {
      set_client_role(from.client_role());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Configuration::CopyFrom(const Configuration& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Configuration::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_encoding()) {
    if (!this->encoding().IsInitialized()) return false;
  }
  return true;
}

void Configuration::Swap(Configuration* other) {
  if (other != this) {
    std::swap(encoding_, other->encoding_);
    std::swap(client_role_, other->client_role_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Configuration::GetTypeName() const {
  return "polo.wire.protobuf.Configuration";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ConfigurationAck::ConfigurationAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:polo.wire.protobuf.ConfigurationAck)
}

void ConfigurationAck::InitAsDefaultInstance() {
}

ConfigurationAck::ConfigurationAck(const ConfigurationAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:polo.wire.protobuf.ConfigurationAck)
}

void ConfigurationAck::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConfigurationAck::~ConfigurationAck() {
  // @@protoc_insertion_point(destructor:polo.wire.protobuf.ConfigurationAck)
  SharedDtor();
}

void ConfigurationAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ConfigurationAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ConfigurationAck& ConfigurationAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_polo_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_polo_2eproto();
#endif
  return *default_instance_;
}

ConfigurationAck* ConfigurationAck::default_instance_ = NULL;

ConfigurationAck* ConfigurationAck::New() const {
  return new ConfigurationAck;
}

void ConfigurationAck::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ConfigurationAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:polo.wire.protobuf.ConfigurationAck)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:polo.wire.protobuf.ConfigurationAck)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:polo.wire.protobuf.ConfigurationAck)
  return false;
#undef DO_
}

void ConfigurationAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:polo.wire.protobuf.ConfigurationAck)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:polo.wire.protobuf.ConfigurationAck)
}

int ConfigurationAck::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConfigurationAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ConfigurationAck*>(&from));
}

void ConfigurationAck::MergeFrom(const ConfigurationAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ConfigurationAck::CopyFrom(const ConfigurationAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigurationAck::IsInitialized() const {

  return true;
}

void ConfigurationAck::Swap(ConfigurationAck* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ConfigurationAck::GetTypeName() const {
  return "polo.wire.protobuf.ConfigurationAck";
}


// ===================================================================

#ifndef _MSC_VER
const int Secret::kSecretFieldNumber;
#endif  // !_MSC_VER

Secret::Secret()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:polo.wire.protobuf.Secret)
}

void Secret::InitAsDefaultInstance() {
}

Secret::Secret(const Secret& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:polo.wire.protobuf.Secret)
}

void Secret::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Secret::~Secret() {
  // @@protoc_insertion_point(destructor:polo.wire.protobuf.Secret)
  SharedDtor();
}

void Secret::SharedDtor() {
  if (secret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete secret_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Secret::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Secret& Secret::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_polo_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_polo_2eproto();
#endif
  return *default_instance_;
}

Secret* Secret::default_instance_ = NULL;

Secret* Secret::New() const {
  return new Secret;
}

void Secret::Clear() {
  if (has_secret()) {
    if (secret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      secret_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Secret::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:polo.wire.protobuf.Secret)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes secret = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_secret()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:polo.wire.protobuf.Secret)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:polo.wire.protobuf.Secret)
  return false;
#undef DO_
}

void Secret::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:polo.wire.protobuf.Secret)
  // required bytes secret = 1;
  if (has_secret()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->secret(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:polo.wire.protobuf.Secret)
}

int Secret::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes secret = 1;
    if (has_secret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->secret());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Secret::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Secret*>(&from));
}

void Secret::MergeFrom(const Secret& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_secret()) {
      set_secret(from.secret());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Secret::CopyFrom(const Secret& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Secret::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Secret::Swap(Secret* other) {
  if (other != this) {
    std::swap(secret_, other->secret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Secret::GetTypeName() const {
  return "polo.wire.protobuf.Secret";
}


// ===================================================================

#ifndef _MSC_VER
const int SecretAck::kSecretFieldNumber;
#endif  // !_MSC_VER

SecretAck::SecretAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:polo.wire.protobuf.SecretAck)
}

void SecretAck::InitAsDefaultInstance() {
}

SecretAck::SecretAck(const SecretAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:polo.wire.protobuf.SecretAck)
}

void SecretAck::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SecretAck::~SecretAck() {
  // @@protoc_insertion_point(destructor:polo.wire.protobuf.SecretAck)
  SharedDtor();
}

void SecretAck::SharedDtor() {
  if (secret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete secret_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SecretAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SecretAck& SecretAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_polo_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_polo_2eproto();
#endif
  return *default_instance_;
}

SecretAck* SecretAck::default_instance_ = NULL;

SecretAck* SecretAck::New() const {
  return new SecretAck;
}

void SecretAck::Clear() {
  if (has_secret()) {
    if (secret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      secret_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SecretAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:polo.wire.protobuf.SecretAck)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes secret = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_secret()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:polo.wire.protobuf.SecretAck)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:polo.wire.protobuf.SecretAck)
  return false;
#undef DO_
}

void SecretAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:polo.wire.protobuf.SecretAck)
  // required bytes secret = 1;
  if (has_secret()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->secret(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:polo.wire.protobuf.SecretAck)
}

int SecretAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes secret = 1;
    if (has_secret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->secret());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SecretAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SecretAck*>(&from));
}

void SecretAck::MergeFrom(const SecretAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_secret()) {
      set_secret(from.secret());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SecretAck::CopyFrom(const SecretAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SecretAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SecretAck::Swap(SecretAck* other) {
  if (other != this) {
    std::swap(secret_, other->secret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SecretAck::GetTypeName() const {
  return "polo.wire.protobuf.SecretAck";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace wire
}  // namespace polo

// @@protoc_insertion_point(global_scope)
