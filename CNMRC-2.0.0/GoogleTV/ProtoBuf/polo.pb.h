// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: polo.proto

#ifndef PROTOBUF_polo_2eproto__INCLUDED
#define PROTOBUF_polo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace polo {
namespace wire {
namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_polo_2eproto();
void protobuf_AssignDesc_polo_2eproto();
void protobuf_ShutdownFile_polo_2eproto();

class OuterMessage;
class PairingRequest;
class PairingRequestAck;
class Options;
class Options_Encoding;
class Configuration;
class ConfigurationAck;
class Secret;
class SecretAck;

enum OuterMessage_MessageType {
  OuterMessage_MessageType_MESSAGE_TYPE_PAIRING_REQUEST = 10,
  OuterMessage_MessageType_MESSAGE_TYPE_PAIRING_REQUEST_ACK = 11,
  OuterMessage_MessageType_MESSAGE_TYPE_OPTIONS = 20,
  OuterMessage_MessageType_MESSAGE_TYPE_CONFIGURATION = 30,
  OuterMessage_MessageType_MESSAGE_TYPE_CONFIGURATION_ACK = 31,
  OuterMessage_MessageType_MESSAGE_TYPE_SECRET = 40,
  OuterMessage_MessageType_MESSAGE_TYPE_SECRET_ACK = 41
};
bool OuterMessage_MessageType_IsValid(int value);
const OuterMessage_MessageType OuterMessage_MessageType_MessageType_MIN = OuterMessage_MessageType_MESSAGE_TYPE_PAIRING_REQUEST;
const OuterMessage_MessageType OuterMessage_MessageType_MessageType_MAX = OuterMessage_MessageType_MESSAGE_TYPE_SECRET_ACK;
const int OuterMessage_MessageType_MessageType_ARRAYSIZE = OuterMessage_MessageType_MessageType_MAX + 1;

enum OuterMessage_Status {
  OuterMessage_Status_STATUS_OK = 200,
  OuterMessage_Status_STATUS_ERROR = 400,
  OuterMessage_Status_STATUS_BAD_CONFIGURATION = 401,
  OuterMessage_Status_STATUS_BAD_SECRET = 402
};
bool OuterMessage_Status_IsValid(int value);
const OuterMessage_Status OuterMessage_Status_Status_MIN = OuterMessage_Status_STATUS_OK;
const OuterMessage_Status OuterMessage_Status_Status_MAX = OuterMessage_Status_STATUS_BAD_SECRET;
const int OuterMessage_Status_Status_ARRAYSIZE = OuterMessage_Status_Status_MAX + 1;

enum Options_Encoding_EncodingType {
  Options_Encoding_EncodingType_ENCODING_TYPE_UNKNOWN = 0,
  Options_Encoding_EncodingType_ENCODING_TYPE_ALPHANUMERIC = 1,
  Options_Encoding_EncodingType_ENCODING_TYPE_NUMERIC = 2,
  Options_Encoding_EncodingType_ENCODING_TYPE_HEXADECIMAL = 3,
  Options_Encoding_EncodingType_ENCODING_TYPE_QRCODE = 4
};
bool Options_Encoding_EncodingType_IsValid(int value);
const Options_Encoding_EncodingType Options_Encoding_EncodingType_EncodingType_MIN = Options_Encoding_EncodingType_ENCODING_TYPE_UNKNOWN;
const Options_Encoding_EncodingType Options_Encoding_EncodingType_EncodingType_MAX = Options_Encoding_EncodingType_ENCODING_TYPE_QRCODE;
const int Options_Encoding_EncodingType_EncodingType_ARRAYSIZE = Options_Encoding_EncodingType_EncodingType_MAX + 1;

enum Options_RoleType {
  Options_RoleType_ROLE_TYPE_UNKNOWN = 0,
  Options_RoleType_ROLE_TYPE_INPUT = 1,
  Options_RoleType_ROLE_TYPE_OUTPUT = 2
};
bool Options_RoleType_IsValid(int value);
const Options_RoleType Options_RoleType_RoleType_MIN = Options_RoleType_ROLE_TYPE_UNKNOWN;
const Options_RoleType Options_RoleType_RoleType_MAX = Options_RoleType_ROLE_TYPE_OUTPUT;
const int Options_RoleType_RoleType_ARRAYSIZE = Options_RoleType_RoleType_MAX + 1;

// ===================================================================

class OuterMessage : public ::google::protobuf::MessageLite {
 public:
  OuterMessage();
  virtual ~OuterMessage();

  OuterMessage(const OuterMessage& from);

  inline OuterMessage& operator=(const OuterMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const OuterMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OuterMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OuterMessage* other);

  // implements Message ----------------------------------------------

  OuterMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OuterMessage& from);
  void MergeFrom(const OuterMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef OuterMessage_MessageType MessageType;
  static const MessageType MESSAGE_TYPE_PAIRING_REQUEST = OuterMessage_MessageType_MESSAGE_TYPE_PAIRING_REQUEST;
  static const MessageType MESSAGE_TYPE_PAIRING_REQUEST_ACK = OuterMessage_MessageType_MESSAGE_TYPE_PAIRING_REQUEST_ACK;
  static const MessageType MESSAGE_TYPE_OPTIONS = OuterMessage_MessageType_MESSAGE_TYPE_OPTIONS;
  static const MessageType MESSAGE_TYPE_CONFIGURATION = OuterMessage_MessageType_MESSAGE_TYPE_CONFIGURATION;
  static const MessageType MESSAGE_TYPE_CONFIGURATION_ACK = OuterMessage_MessageType_MESSAGE_TYPE_CONFIGURATION_ACK;
  static const MessageType MESSAGE_TYPE_SECRET = OuterMessage_MessageType_MESSAGE_TYPE_SECRET;
  static const MessageType MESSAGE_TYPE_SECRET_ACK = OuterMessage_MessageType_MESSAGE_TYPE_SECRET_ACK;
  static inline bool MessageType_IsValid(int value) {
    return OuterMessage_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    OuterMessage_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    OuterMessage_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    OuterMessage_MessageType_MessageType_ARRAYSIZE;

  typedef OuterMessage_Status Status;
  static const Status STATUS_OK = OuterMessage_Status_STATUS_OK;
  static const Status STATUS_ERROR = OuterMessage_Status_STATUS_ERROR;
  static const Status STATUS_BAD_CONFIGURATION = OuterMessage_Status_STATUS_BAD_CONFIGURATION;
  static const Status STATUS_BAD_SECRET = OuterMessage_Status_STATUS_BAD_SECRET;
  static inline bool Status_IsValid(int value) {
    return OuterMessage_Status_IsValid(value);
  }
  static const Status Status_MIN =
    OuterMessage_Status_Status_MIN;
  static const Status Status_MAX =
    OuterMessage_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    OuterMessage_Status_Status_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 protocol_version = 1 [default = 1];
  inline bool has_protocol_version() const;
  inline void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 protocol_version() const;
  inline void set_protocol_version(::google::protobuf::uint32 value);

  // required .polo.wire.protobuf.OuterMessage.Status status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::polo::wire::protobuf::OuterMessage_Status status() const;
  inline void set_status(::polo::wire::protobuf::OuterMessage_Status value);

  // optional .polo.wire.protobuf.OuterMessage.MessageType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::polo::wire::protobuf::OuterMessage_MessageType type() const;
  inline void set_type(::polo::wire::protobuf::OuterMessage_MessageType value);

  // optional bytes payload = 4;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 4;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:polo.wire.protobuf.OuterMessage)
 private:
  inline void set_has_protocol_version();
  inline void clear_has_protocol_version();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_payload();
  inline void clear_has_payload();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 protocol_version_;
  int status_;
  ::std::string* payload_;
  int type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_polo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_polo_2eproto();
  #endif
  friend void protobuf_AssignDesc_polo_2eproto();
  friend void protobuf_ShutdownFile_polo_2eproto();

  void InitAsDefaultInstance();
  static OuterMessage* default_instance_;
};
// -------------------------------------------------------------------

class PairingRequest : public ::google::protobuf::MessageLite {
 public:
  PairingRequest();
  virtual ~PairingRequest();

  PairingRequest(const PairingRequest& from);

  inline PairingRequest& operator=(const PairingRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PairingRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PairingRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PairingRequest* other);

  // implements Message ----------------------------------------------

  PairingRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PairingRequest& from);
  void MergeFrom(const PairingRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string service_name = 1;
  inline bool has_service_name() const;
  inline void clear_service_name();
  static const int kServiceNameFieldNumber = 1;
  inline const ::std::string& service_name() const;
  inline void set_service_name(const ::std::string& value);
  inline void set_service_name(const char* value);
  inline void set_service_name(const char* value, size_t size);
  inline ::std::string* mutable_service_name();
  inline ::std::string* release_service_name();
  inline void set_allocated_service_name(::std::string* service_name);

  // optional string client_name = 2;
  inline bool has_client_name() const;
  inline void clear_client_name();
  static const int kClientNameFieldNumber = 2;
  inline const ::std::string& client_name() const;
  inline void set_client_name(const ::std::string& value);
  inline void set_client_name(const char* value);
  inline void set_client_name(const char* value, size_t size);
  inline ::std::string* mutable_client_name();
  inline ::std::string* release_client_name();
  inline void set_allocated_client_name(::std::string* client_name);

  // @@protoc_insertion_point(class_scope:polo.wire.protobuf.PairingRequest)
 private:
  inline void set_has_service_name();
  inline void clear_has_service_name();
  inline void set_has_client_name();
  inline void clear_has_client_name();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* service_name_;
  ::std::string* client_name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_polo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_polo_2eproto();
  #endif
  friend void protobuf_AssignDesc_polo_2eproto();
  friend void protobuf_ShutdownFile_polo_2eproto();

  void InitAsDefaultInstance();
  static PairingRequest* default_instance_;
};
// -------------------------------------------------------------------

class PairingRequestAck : public ::google::protobuf::MessageLite {
 public:
  PairingRequestAck();
  virtual ~PairingRequestAck();

  PairingRequestAck(const PairingRequestAck& from);

  inline PairingRequestAck& operator=(const PairingRequestAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PairingRequestAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PairingRequestAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PairingRequestAck* other);

  // implements Message ----------------------------------------------

  PairingRequestAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PairingRequestAck& from);
  void MergeFrom(const PairingRequestAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string server_name = 1;
  inline bool has_server_name() const;
  inline void clear_server_name();
  static const int kServerNameFieldNumber = 1;
  inline const ::std::string& server_name() const;
  inline void set_server_name(const ::std::string& value);
  inline void set_server_name(const char* value);
  inline void set_server_name(const char* value, size_t size);
  inline ::std::string* mutable_server_name();
  inline ::std::string* release_server_name();
  inline void set_allocated_server_name(::std::string* server_name);

  // @@protoc_insertion_point(class_scope:polo.wire.protobuf.PairingRequestAck)
 private:
  inline void set_has_server_name();
  inline void clear_has_server_name();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* server_name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_polo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_polo_2eproto();
  #endif
  friend void protobuf_AssignDesc_polo_2eproto();
  friend void protobuf_ShutdownFile_polo_2eproto();

  void InitAsDefaultInstance();
  static PairingRequestAck* default_instance_;
};
// -------------------------------------------------------------------

class Options_Encoding : public ::google::protobuf::MessageLite {
 public:
  Options_Encoding();
  virtual ~Options_Encoding();

  Options_Encoding(const Options_Encoding& from);

  inline Options_Encoding& operator=(const Options_Encoding& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Options_Encoding& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Options_Encoding* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Options_Encoding* other);

  // implements Message ----------------------------------------------

  Options_Encoding* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Options_Encoding& from);
  void MergeFrom(const Options_Encoding& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Options_Encoding_EncodingType EncodingType;
  static const EncodingType ENCODING_TYPE_UNKNOWN = Options_Encoding_EncodingType_ENCODING_TYPE_UNKNOWN;
  static const EncodingType ENCODING_TYPE_ALPHANUMERIC = Options_Encoding_EncodingType_ENCODING_TYPE_ALPHANUMERIC;
  static const EncodingType ENCODING_TYPE_NUMERIC = Options_Encoding_EncodingType_ENCODING_TYPE_NUMERIC;
  static const EncodingType ENCODING_TYPE_HEXADECIMAL = Options_Encoding_EncodingType_ENCODING_TYPE_HEXADECIMAL;
  static const EncodingType ENCODING_TYPE_QRCODE = Options_Encoding_EncodingType_ENCODING_TYPE_QRCODE;
  static inline bool EncodingType_IsValid(int value) {
    return Options_Encoding_EncodingType_IsValid(value);
  }
  static const EncodingType EncodingType_MIN =
    Options_Encoding_EncodingType_EncodingType_MIN;
  static const EncodingType EncodingType_MAX =
    Options_Encoding_EncodingType_EncodingType_MAX;
  static const int EncodingType_ARRAYSIZE =
    Options_Encoding_EncodingType_EncodingType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .polo.wire.protobuf.Options.Encoding.EncodingType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::polo::wire::protobuf::Options_Encoding_EncodingType type() const;
  inline void set_type(::polo::wire::protobuf::Options_Encoding_EncodingType value);

  // required uint32 symbol_length = 2;
  inline bool has_symbol_length() const;
  inline void clear_symbol_length();
  static const int kSymbolLengthFieldNumber = 2;
  inline ::google::protobuf::uint32 symbol_length() const;
  inline void set_symbol_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:polo.wire.protobuf.Options.Encoding)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_symbol_length();
  inline void clear_has_symbol_length();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  ::google::protobuf::uint32 symbol_length_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_polo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_polo_2eproto();
  #endif
  friend void protobuf_AssignDesc_polo_2eproto();
  friend void protobuf_ShutdownFile_polo_2eproto();

  void InitAsDefaultInstance();
  static Options_Encoding* default_instance_;
};
// -------------------------------------------------------------------

class Options : public ::google::protobuf::MessageLite {
 public:
  Options();
  virtual ~Options();

  Options(const Options& from);

  inline Options& operator=(const Options& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Options& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Options* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Options* other);

  // implements Message ----------------------------------------------

  Options* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Options& from);
  void MergeFrom(const Options& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Options_Encoding Encoding;

  typedef Options_RoleType RoleType;
  static const RoleType ROLE_TYPE_UNKNOWN = Options_RoleType_ROLE_TYPE_UNKNOWN;
  static const RoleType ROLE_TYPE_INPUT = Options_RoleType_ROLE_TYPE_INPUT;
  static const RoleType ROLE_TYPE_OUTPUT = Options_RoleType_ROLE_TYPE_OUTPUT;
  static inline bool RoleType_IsValid(int value) {
    return Options_RoleType_IsValid(value);
  }
  static const RoleType RoleType_MIN =
    Options_RoleType_RoleType_MIN;
  static const RoleType RoleType_MAX =
    Options_RoleType_RoleType_MAX;
  static const int RoleType_ARRAYSIZE =
    Options_RoleType_RoleType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .polo.wire.protobuf.Options.Encoding input_encodings = 1;
  inline int input_encodings_size() const;
  inline void clear_input_encodings();
  static const int kInputEncodingsFieldNumber = 1;
  inline const ::polo::wire::protobuf::Options_Encoding& input_encodings(int index) const;
  inline ::polo::wire::protobuf::Options_Encoding* mutable_input_encodings(int index);
  inline ::polo::wire::protobuf::Options_Encoding* add_input_encodings();
  inline const ::google::protobuf::RepeatedPtrField< ::polo::wire::protobuf::Options_Encoding >&
      input_encodings() const;
  inline ::google::protobuf::RepeatedPtrField< ::polo::wire::protobuf::Options_Encoding >*
      mutable_input_encodings();

  // repeated .polo.wire.protobuf.Options.Encoding output_encodings = 2;
  inline int output_encodings_size() const;
  inline void clear_output_encodings();
  static const int kOutputEncodingsFieldNumber = 2;
  inline const ::polo::wire::protobuf::Options_Encoding& output_encodings(int index) const;
  inline ::polo::wire::protobuf::Options_Encoding* mutable_output_encodings(int index);
  inline ::polo::wire::protobuf::Options_Encoding* add_output_encodings();
  inline const ::google::protobuf::RepeatedPtrField< ::polo::wire::protobuf::Options_Encoding >&
      output_encodings() const;
  inline ::google::protobuf::RepeatedPtrField< ::polo::wire::protobuf::Options_Encoding >*
      mutable_output_encodings();

  // optional .polo.wire.protobuf.Options.RoleType preferred_role = 3;
  inline bool has_preferred_role() const;
  inline void clear_preferred_role();
  static const int kPreferredRoleFieldNumber = 3;
  inline ::polo::wire::protobuf::Options_RoleType preferred_role() const;
  inline void set_preferred_role(::polo::wire::protobuf::Options_RoleType value);

  // @@protoc_insertion_point(class_scope:polo.wire.protobuf.Options)
 private:
  inline void set_has_preferred_role();
  inline void clear_has_preferred_role();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::polo::wire::protobuf::Options_Encoding > input_encodings_;
  ::google::protobuf::RepeatedPtrField< ::polo::wire::protobuf::Options_Encoding > output_encodings_;
  int preferred_role_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_polo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_polo_2eproto();
  #endif
  friend void protobuf_AssignDesc_polo_2eproto();
  friend void protobuf_ShutdownFile_polo_2eproto();

  void InitAsDefaultInstance();
  static Options* default_instance_;
};
// -------------------------------------------------------------------

class Configuration : public ::google::protobuf::MessageLite {
 public:
  Configuration();
  virtual ~Configuration();

  Configuration(const Configuration& from);

  inline Configuration& operator=(const Configuration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Configuration& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Configuration* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Configuration* other);

  // implements Message ----------------------------------------------

  Configuration* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Configuration& from);
  void MergeFrom(const Configuration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .polo.wire.protobuf.Options.Encoding encoding = 1;
  inline bool has_encoding() const;
  inline void clear_encoding();
  static const int kEncodingFieldNumber = 1;
  inline const ::polo::wire::protobuf::Options_Encoding& encoding() const;
  inline ::polo::wire::protobuf::Options_Encoding* mutable_encoding();
  inline ::polo::wire::protobuf::Options_Encoding* release_encoding();
  inline void set_allocated_encoding(::polo::wire::protobuf::Options_Encoding* encoding);

  // required .polo.wire.protobuf.Options.RoleType client_role = 2;
  inline bool has_client_role() const;
  inline void clear_client_role();
  static const int kClientRoleFieldNumber = 2;
  inline ::polo::wire::protobuf::Options_RoleType client_role() const;
  inline void set_client_role(::polo::wire::protobuf::Options_RoleType value);

  // @@protoc_insertion_point(class_scope:polo.wire.protobuf.Configuration)
 private:
  inline void set_has_encoding();
  inline void clear_has_encoding();
  inline void set_has_client_role();
  inline void clear_has_client_role();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::polo::wire::protobuf::Options_Encoding* encoding_;
  int client_role_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_polo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_polo_2eproto();
  #endif
  friend void protobuf_AssignDesc_polo_2eproto();
  friend void protobuf_ShutdownFile_polo_2eproto();

  void InitAsDefaultInstance();
  static Configuration* default_instance_;
};
// -------------------------------------------------------------------

class ConfigurationAck : public ::google::protobuf::MessageLite {
 public:
  ConfigurationAck();
  virtual ~ConfigurationAck();

  ConfigurationAck(const ConfigurationAck& from);

  inline ConfigurationAck& operator=(const ConfigurationAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ConfigurationAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConfigurationAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConfigurationAck* other);

  // implements Message ----------------------------------------------

  ConfigurationAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConfigurationAck& from);
  void MergeFrom(const ConfigurationAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:polo.wire.protobuf.ConfigurationAck)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_polo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_polo_2eproto();
  #endif
  friend void protobuf_AssignDesc_polo_2eproto();
  friend void protobuf_ShutdownFile_polo_2eproto();

  void InitAsDefaultInstance();
  static ConfigurationAck* default_instance_;
};
// -------------------------------------------------------------------

class Secret : public ::google::protobuf::MessageLite {
 public:
  Secret();
  virtual ~Secret();

  Secret(const Secret& from);

  inline Secret& operator=(const Secret& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Secret& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Secret* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Secret* other);

  // implements Message ----------------------------------------------

  Secret* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Secret& from);
  void MergeFrom(const Secret& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes secret = 1;
  inline bool has_secret() const;
  inline void clear_secret();
  static const int kSecretFieldNumber = 1;
  inline const ::std::string& secret() const;
  inline void set_secret(const ::std::string& value);
  inline void set_secret(const char* value);
  inline void set_secret(const void* value, size_t size);
  inline ::std::string* mutable_secret();
  inline ::std::string* release_secret();
  inline void set_allocated_secret(::std::string* secret);

  // @@protoc_insertion_point(class_scope:polo.wire.protobuf.Secret)
 private:
  inline void set_has_secret();
  inline void clear_has_secret();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* secret_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_polo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_polo_2eproto();
  #endif
  friend void protobuf_AssignDesc_polo_2eproto();
  friend void protobuf_ShutdownFile_polo_2eproto();

  void InitAsDefaultInstance();
  static Secret* default_instance_;
};
// -------------------------------------------------------------------

class SecretAck : public ::google::protobuf::MessageLite {
 public:
  SecretAck();
  virtual ~SecretAck();

  SecretAck(const SecretAck& from);

  inline SecretAck& operator=(const SecretAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SecretAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SecretAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SecretAck* other);

  // implements Message ----------------------------------------------

  SecretAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SecretAck& from);
  void MergeFrom(const SecretAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes secret = 1;
  inline bool has_secret() const;
  inline void clear_secret();
  static const int kSecretFieldNumber = 1;
  inline const ::std::string& secret() const;
  inline void set_secret(const ::std::string& value);
  inline void set_secret(const char* value);
  inline void set_secret(const void* value, size_t size);
  inline ::std::string* mutable_secret();
  inline ::std::string* release_secret();
  inline void set_allocated_secret(::std::string* secret);

  // @@protoc_insertion_point(class_scope:polo.wire.protobuf.SecretAck)
 private:
  inline void set_has_secret();
  inline void clear_has_secret();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* secret_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_polo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_polo_2eproto();
  #endif
  friend void protobuf_AssignDesc_polo_2eproto();
  friend void protobuf_ShutdownFile_polo_2eproto();

  void InitAsDefaultInstance();
  static SecretAck* default_instance_;
};
// ===================================================================


// ===================================================================

// OuterMessage

// required uint32 protocol_version = 1 [default = 1];
inline bool OuterMessage::has_protocol_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OuterMessage::set_has_protocol_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OuterMessage::clear_has_protocol_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OuterMessage::clear_protocol_version() {
  protocol_version_ = 1u;
  clear_has_protocol_version();
}
inline ::google::protobuf::uint32 OuterMessage::protocol_version() const {
  // @@protoc_insertion_point(field_get:polo.wire.protobuf.OuterMessage.protocol_version)
  return protocol_version_;
}
inline void OuterMessage::set_protocol_version(::google::protobuf::uint32 value) {
  set_has_protocol_version();
  protocol_version_ = value;
  // @@protoc_insertion_point(field_set:polo.wire.protobuf.OuterMessage.protocol_version)
}

// required .polo.wire.protobuf.OuterMessage.Status status = 2;
inline bool OuterMessage::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OuterMessage::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OuterMessage::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OuterMessage::clear_status() {
  status_ = 200;
  clear_has_status();
}
inline ::polo::wire::protobuf::OuterMessage_Status OuterMessage::status() const {
  // @@protoc_insertion_point(field_get:polo.wire.protobuf.OuterMessage.status)
  return static_cast< ::polo::wire::protobuf::OuterMessage_Status >(status_);
}
inline void OuterMessage::set_status(::polo::wire::protobuf::OuterMessage_Status value) {
  assert(::polo::wire::protobuf::OuterMessage_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:polo.wire.protobuf.OuterMessage.status)
}

// optional .polo.wire.protobuf.OuterMessage.MessageType type = 3;
inline bool OuterMessage::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OuterMessage::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OuterMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OuterMessage::clear_type() {
  type_ = 10;
  clear_has_type();
}
inline ::polo::wire::protobuf::OuterMessage_MessageType OuterMessage::type() const {
  // @@protoc_insertion_point(field_get:polo.wire.protobuf.OuterMessage.type)
  return static_cast< ::polo::wire::protobuf::OuterMessage_MessageType >(type_);
}
inline void OuterMessage::set_type(::polo::wire::protobuf::OuterMessage_MessageType value) {
  assert(::polo::wire::protobuf::OuterMessage_MessageType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:polo.wire.protobuf.OuterMessage.type)
}

// optional bytes payload = 4;
inline bool OuterMessage::has_payload() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OuterMessage::set_has_payload() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OuterMessage::clear_has_payload() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OuterMessage::clear_payload() {
  if (payload_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& OuterMessage::payload() const {
  // @@protoc_insertion_point(field_get:polo.wire.protobuf.OuterMessage.payload)
  return *payload_;
}
inline void OuterMessage::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
  // @@protoc_insertion_point(field_set:polo.wire.protobuf.OuterMessage.payload)
}
inline void OuterMessage::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
  // @@protoc_insertion_point(field_set_char:polo.wire.protobuf.OuterMessage.payload)
}
inline void OuterMessage::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:polo.wire.protobuf.OuterMessage.payload)
}
inline ::std::string* OuterMessage::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:polo.wire.protobuf.OuterMessage.payload)
  return payload_;
}
inline ::std::string* OuterMessage::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OuterMessage::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:polo.wire.protobuf.OuterMessage.payload)
}

// -------------------------------------------------------------------

// PairingRequest

// required string service_name = 1;
inline bool PairingRequest::has_service_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PairingRequest::set_has_service_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PairingRequest::clear_has_service_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PairingRequest::clear_service_name() {
  if (service_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_name_->clear();
  }
  clear_has_service_name();
}
inline const ::std::string& PairingRequest::service_name() const {
  // @@protoc_insertion_point(field_get:polo.wire.protobuf.PairingRequest.service_name)
  return *service_name_;
}
inline void PairingRequest::set_service_name(const ::std::string& value) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
  // @@protoc_insertion_point(field_set:polo.wire.protobuf.PairingRequest.service_name)
}
inline void PairingRequest::set_service_name(const char* value) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:polo.wire.protobuf.PairingRequest.service_name)
}
inline void PairingRequest::set_service_name(const char* value, size_t size) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:polo.wire.protobuf.PairingRequest.service_name)
}
inline ::std::string* PairingRequest::mutable_service_name() {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:polo.wire.protobuf.PairingRequest.service_name)
  return service_name_;
}
inline ::std::string* PairingRequest::release_service_name() {
  clear_has_service_name();
  if (service_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = service_name_;
    service_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PairingRequest::set_allocated_service_name(::std::string* service_name) {
  if (service_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_name_;
  }
  if (service_name) {
    set_has_service_name();
    service_name_ = service_name;
  } else {
    clear_has_service_name();
    service_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:polo.wire.protobuf.PairingRequest.service_name)
}

// optional string client_name = 2;
inline bool PairingRequest::has_client_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PairingRequest::set_has_client_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PairingRequest::clear_has_client_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PairingRequest::clear_client_name() {
  if (client_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_name_->clear();
  }
  clear_has_client_name();
}
inline const ::std::string& PairingRequest::client_name() const {
  // @@protoc_insertion_point(field_get:polo.wire.protobuf.PairingRequest.client_name)
  return *client_name_;
}
inline void PairingRequest::set_client_name(const ::std::string& value) {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_name_ = new ::std::string;
  }
  client_name_->assign(value);
  // @@protoc_insertion_point(field_set:polo.wire.protobuf.PairingRequest.client_name)
}
inline void PairingRequest::set_client_name(const char* value) {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_name_ = new ::std::string;
  }
  client_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:polo.wire.protobuf.PairingRequest.client_name)
}
inline void PairingRequest::set_client_name(const char* value, size_t size) {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_name_ = new ::std::string;
  }
  client_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:polo.wire.protobuf.PairingRequest.client_name)
}
inline ::std::string* PairingRequest::mutable_client_name() {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:polo.wire.protobuf.PairingRequest.client_name)
  return client_name_;
}
inline ::std::string* PairingRequest::release_client_name() {
  clear_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_name_;
    client_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PairingRequest::set_allocated_client_name(::std::string* client_name) {
  if (client_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_name_;
  }
  if (client_name) {
    set_has_client_name();
    client_name_ = client_name;
  } else {
    clear_has_client_name();
    client_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:polo.wire.protobuf.PairingRequest.client_name)
}

// -------------------------------------------------------------------

// PairingRequestAck

// optional string server_name = 1;
inline bool PairingRequestAck::has_server_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PairingRequestAck::set_has_server_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PairingRequestAck::clear_has_server_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PairingRequestAck::clear_server_name() {
  if (server_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_name_->clear();
  }
  clear_has_server_name();
}
inline const ::std::string& PairingRequestAck::server_name() const {
  // @@protoc_insertion_point(field_get:polo.wire.protobuf.PairingRequestAck.server_name)
  return *server_name_;
}
inline void PairingRequestAck::set_server_name(const ::std::string& value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
  // @@protoc_insertion_point(field_set:polo.wire.protobuf.PairingRequestAck.server_name)
}
inline void PairingRequestAck::set_server_name(const char* value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:polo.wire.protobuf.PairingRequestAck.server_name)
}
inline void PairingRequestAck::set_server_name(const char* value, size_t size) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:polo.wire.protobuf.PairingRequestAck.server_name)
}
inline ::std::string* PairingRequestAck::mutable_server_name() {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:polo.wire.protobuf.PairingRequestAck.server_name)
  return server_name_;
}
inline ::std::string* PairingRequestAck::release_server_name() {
  clear_has_server_name();
  if (server_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = server_name_;
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PairingRequestAck::set_allocated_server_name(::std::string* server_name) {
  if (server_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete server_name_;
  }
  if (server_name) {
    set_has_server_name();
    server_name_ = server_name;
  } else {
    clear_has_server_name();
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:polo.wire.protobuf.PairingRequestAck.server_name)
}

// -------------------------------------------------------------------

// Options_Encoding

// required .polo.wire.protobuf.Options.Encoding.EncodingType type = 1;
inline bool Options_Encoding::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Options_Encoding::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Options_Encoding::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Options_Encoding::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::polo::wire::protobuf::Options_Encoding_EncodingType Options_Encoding::type() const {
  // @@protoc_insertion_point(field_get:polo.wire.protobuf.Options.Encoding.type)
  return static_cast< ::polo::wire::protobuf::Options_Encoding_EncodingType >(type_);
}
inline void Options_Encoding::set_type(::polo::wire::protobuf::Options_Encoding_EncodingType value) {
  assert(::polo::wire::protobuf::Options_Encoding_EncodingType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:polo.wire.protobuf.Options.Encoding.type)
}

// required uint32 symbol_length = 2;
inline bool Options_Encoding::has_symbol_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Options_Encoding::set_has_symbol_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Options_Encoding::clear_has_symbol_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Options_Encoding::clear_symbol_length() {
  symbol_length_ = 0u;
  clear_has_symbol_length();
}
inline ::google::protobuf::uint32 Options_Encoding::symbol_length() const {
  // @@protoc_insertion_point(field_get:polo.wire.protobuf.Options.Encoding.symbol_length)
  return symbol_length_;
}
inline void Options_Encoding::set_symbol_length(::google::protobuf::uint32 value) {
  set_has_symbol_length();
  symbol_length_ = value;
  // @@protoc_insertion_point(field_set:polo.wire.protobuf.Options.Encoding.symbol_length)
}

// -------------------------------------------------------------------

// Options

// repeated .polo.wire.protobuf.Options.Encoding input_encodings = 1;
inline int Options::input_encodings_size() const {
  return input_encodings_.size();
}
inline void Options::clear_input_encodings() {
  input_encodings_.Clear();
}
inline const ::polo::wire::protobuf::Options_Encoding& Options::input_encodings(int index) const {
  // @@protoc_insertion_point(field_get:polo.wire.protobuf.Options.input_encodings)
  return input_encodings_.Get(index);
}
inline ::polo::wire::protobuf::Options_Encoding* Options::mutable_input_encodings(int index) {
  // @@protoc_insertion_point(field_mutable:polo.wire.protobuf.Options.input_encodings)
  return input_encodings_.Mutable(index);
}
inline ::polo::wire::protobuf::Options_Encoding* Options::add_input_encodings() {
  // @@protoc_insertion_point(field_add:polo.wire.protobuf.Options.input_encodings)
  return input_encodings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::polo::wire::protobuf::Options_Encoding >&
Options::input_encodings() const {
  // @@protoc_insertion_point(field_list:polo.wire.protobuf.Options.input_encodings)
  return input_encodings_;
}
inline ::google::protobuf::RepeatedPtrField< ::polo::wire::protobuf::Options_Encoding >*
Options::mutable_input_encodings() {
  // @@protoc_insertion_point(field_mutable_list:polo.wire.protobuf.Options.input_encodings)
  return &input_encodings_;
}

// repeated .polo.wire.protobuf.Options.Encoding output_encodings = 2;
inline int Options::output_encodings_size() const {
  return output_encodings_.size();
}
inline void Options::clear_output_encodings() {
  output_encodings_.Clear();
}
inline const ::polo::wire::protobuf::Options_Encoding& Options::output_encodings(int index) const {
  // @@protoc_insertion_point(field_get:polo.wire.protobuf.Options.output_encodings)
  return output_encodings_.Get(index);
}
inline ::polo::wire::protobuf::Options_Encoding* Options::mutable_output_encodings(int index) {
  // @@protoc_insertion_point(field_mutable:polo.wire.protobuf.Options.output_encodings)
  return output_encodings_.Mutable(index);
}
inline ::polo::wire::protobuf::Options_Encoding* Options::add_output_encodings() {
  // @@protoc_insertion_point(field_add:polo.wire.protobuf.Options.output_encodings)
  return output_encodings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::polo::wire::protobuf::Options_Encoding >&
Options::output_encodings() const {
  // @@protoc_insertion_point(field_list:polo.wire.protobuf.Options.output_encodings)
  return output_encodings_;
}
inline ::google::protobuf::RepeatedPtrField< ::polo::wire::protobuf::Options_Encoding >*
Options::mutable_output_encodings() {
  // @@protoc_insertion_point(field_mutable_list:polo.wire.protobuf.Options.output_encodings)
  return &output_encodings_;
}

// optional .polo.wire.protobuf.Options.RoleType preferred_role = 3;
inline bool Options::has_preferred_role() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Options::set_has_preferred_role() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Options::clear_has_preferred_role() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Options::clear_preferred_role() {
  preferred_role_ = 0;
  clear_has_preferred_role();
}
inline ::polo::wire::protobuf::Options_RoleType Options::preferred_role() const {
  // @@protoc_insertion_point(field_get:polo.wire.protobuf.Options.preferred_role)
  return static_cast< ::polo::wire::protobuf::Options_RoleType >(preferred_role_);
}
inline void Options::set_preferred_role(::polo::wire::protobuf::Options_RoleType value) {
  assert(::polo::wire::protobuf::Options_RoleType_IsValid(value));
  set_has_preferred_role();
  preferred_role_ = value;
  // @@protoc_insertion_point(field_set:polo.wire.protobuf.Options.preferred_role)
}

// -------------------------------------------------------------------

// Configuration

// required .polo.wire.protobuf.Options.Encoding encoding = 1;
inline bool Configuration::has_encoding() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Configuration::set_has_encoding() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Configuration::clear_has_encoding() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Configuration::clear_encoding() {
  if (encoding_ != NULL) encoding_->::polo::wire::protobuf::Options_Encoding::Clear();
  clear_has_encoding();
}
inline const ::polo::wire::protobuf::Options_Encoding& Configuration::encoding() const {
  // @@protoc_insertion_point(field_get:polo.wire.protobuf.Configuration.encoding)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return encoding_ != NULL ? *encoding_ : *default_instance().encoding_;
#else
  return encoding_ != NULL ? *encoding_ : *default_instance_->encoding_;
#endif
}
inline ::polo::wire::protobuf::Options_Encoding* Configuration::mutable_encoding() {
  set_has_encoding();
  if (encoding_ == NULL) encoding_ = new ::polo::wire::protobuf::Options_Encoding;
  // @@protoc_insertion_point(field_mutable:polo.wire.protobuf.Configuration.encoding)
  return encoding_;
}
inline ::polo::wire::protobuf::Options_Encoding* Configuration::release_encoding() {
  clear_has_encoding();
  ::polo::wire::protobuf::Options_Encoding* temp = encoding_;
  encoding_ = NULL;
  return temp;
}
inline void Configuration::set_allocated_encoding(::polo::wire::protobuf::Options_Encoding* encoding) {
  delete encoding_;
  encoding_ = encoding;
  if (encoding) {
    set_has_encoding();
  } else {
    clear_has_encoding();
  }
  // @@protoc_insertion_point(field_set_allocated:polo.wire.protobuf.Configuration.encoding)
}

// required .polo.wire.protobuf.Options.RoleType client_role = 2;
inline bool Configuration::has_client_role() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Configuration::set_has_client_role() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Configuration::clear_has_client_role() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Configuration::clear_client_role() {
  client_role_ = 0;
  clear_has_client_role();
}
inline ::polo::wire::protobuf::Options_RoleType Configuration::client_role() const {
  // @@protoc_insertion_point(field_get:polo.wire.protobuf.Configuration.client_role)
  return static_cast< ::polo::wire::protobuf::Options_RoleType >(client_role_);
}
inline void Configuration::set_client_role(::polo::wire::protobuf::Options_RoleType value) {
  assert(::polo::wire::protobuf::Options_RoleType_IsValid(value));
  set_has_client_role();
  client_role_ = value;
  // @@protoc_insertion_point(field_set:polo.wire.protobuf.Configuration.client_role)
}

// -------------------------------------------------------------------

// ConfigurationAck

// -------------------------------------------------------------------

// Secret

// required bytes secret = 1;
inline bool Secret::has_secret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Secret::set_has_secret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Secret::clear_has_secret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Secret::clear_secret() {
  if (secret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_->clear();
  }
  clear_has_secret();
}
inline const ::std::string& Secret::secret() const {
  // @@protoc_insertion_point(field_get:polo.wire.protobuf.Secret.secret)
  return *secret_;
}
inline void Secret::set_secret(const ::std::string& value) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_ = new ::std::string;
  }
  secret_->assign(value);
  // @@protoc_insertion_point(field_set:polo.wire.protobuf.Secret.secret)
}
inline void Secret::set_secret(const char* value) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_ = new ::std::string;
  }
  secret_->assign(value);
  // @@protoc_insertion_point(field_set_char:polo.wire.protobuf.Secret.secret)
}
inline void Secret::set_secret(const void* value, size_t size) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_ = new ::std::string;
  }
  secret_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:polo.wire.protobuf.Secret.secret)
}
inline ::std::string* Secret::mutable_secret() {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:polo.wire.protobuf.Secret.secret)
  return secret_;
}
inline ::std::string* Secret::release_secret() {
  clear_has_secret();
  if (secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = secret_;
    secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Secret::set_allocated_secret(::std::string* secret) {
  if (secret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete secret_;
  }
  if (secret) {
    set_has_secret();
    secret_ = secret;
  } else {
    clear_has_secret();
    secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:polo.wire.protobuf.Secret.secret)
}

// -------------------------------------------------------------------

// SecretAck

// required bytes secret = 1;
inline bool SecretAck::has_secret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecretAck::set_has_secret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecretAck::clear_has_secret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecretAck::clear_secret() {
  if (secret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_->clear();
  }
  clear_has_secret();
}
inline const ::std::string& SecretAck::secret() const {
  // @@protoc_insertion_point(field_get:polo.wire.protobuf.SecretAck.secret)
  return *secret_;
}
inline void SecretAck::set_secret(const ::std::string& value) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_ = new ::std::string;
  }
  secret_->assign(value);
  // @@protoc_insertion_point(field_set:polo.wire.protobuf.SecretAck.secret)
}
inline void SecretAck::set_secret(const char* value) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_ = new ::std::string;
  }
  secret_->assign(value);
  // @@protoc_insertion_point(field_set_char:polo.wire.protobuf.SecretAck.secret)
}
inline void SecretAck::set_secret(const void* value, size_t size) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_ = new ::std::string;
  }
  secret_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:polo.wire.protobuf.SecretAck.secret)
}
inline ::std::string* SecretAck::mutable_secret() {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:polo.wire.protobuf.SecretAck.secret)
  return secret_;
}
inline ::std::string* SecretAck::release_secret() {
  clear_has_secret();
  if (secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = secret_;
    secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SecretAck::set_allocated_secret(::std::string* secret) {
  if (secret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete secret_;
  }
  if (secret) {
    set_has_secret();
    secret_ = secret;
  } else {
    clear_has_secret();
    secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:polo.wire.protobuf.SecretAck.secret)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace wire
}  // namespace polo

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_polo_2eproto__INCLUDED
