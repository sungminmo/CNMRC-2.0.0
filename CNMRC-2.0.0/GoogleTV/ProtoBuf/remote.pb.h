// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: remote.proto

#ifndef PROTOBUF_remote_2eproto__INCLUDED
#define PROTOBUF_remote_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "keycodes.pb.h"
// @@protoc_insertion_point(includes)

namespace anymote {
namespace messages {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_remote_2eproto();
void protobuf_AssignDesc_remote_2eproto();
void protobuf_ShutdownFile_remote_2eproto();

class RemoteMessage;
class RequestMessage;
class ResponseMessage;
class KeyEvent;
class MouseEvent;
class MouseWheel;
class Connect;
class Fling;
class Data;
class FlingResult;

enum FlingResult_Result {
  FlingResult_Result_SUCCESS = 0,
  FlingResult_Result_FAILURE = 1
};
bool FlingResult_Result_IsValid(int value);
const FlingResult_Result FlingResult_Result_Result_MIN = FlingResult_Result_SUCCESS;
const FlingResult_Result FlingResult_Result_Result_MAX = FlingResult_Result_FAILURE;
const int FlingResult_Result_Result_ARRAYSIZE = FlingResult_Result_Result_MAX + 1;

// ===================================================================

class RemoteMessage : public ::google::protobuf::MessageLite {
 public:
  RemoteMessage();
  virtual ~RemoteMessage();

  RemoteMessage(const RemoteMessage& from);

  inline RemoteMessage& operator=(const RemoteMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RemoteMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RemoteMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RemoteMessage* other);

  // implements Message ----------------------------------------------

  RemoteMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RemoteMessage& from);
  void MergeFrom(const RemoteMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sequence_number = 1;
  inline bool has_sequence_number() const;
  inline void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 sequence_number() const;
  inline void set_sequence_number(::google::protobuf::uint32 value);

  // optional .anymote.messages.RequestMessage request_message = 2;
  inline bool has_request_message() const;
  inline void clear_request_message();
  static const int kRequestMessageFieldNumber = 2;
  inline const ::anymote::messages::RequestMessage& request_message() const;
  inline ::anymote::messages::RequestMessage* mutable_request_message();
  inline ::anymote::messages::RequestMessage* release_request_message();
  inline void set_allocated_request_message(::anymote::messages::RequestMessage* request_message);

  // optional .anymote.messages.ResponseMessage response_message = 3;
  inline bool has_response_message() const;
  inline void clear_response_message();
  static const int kResponseMessageFieldNumber = 3;
  inline const ::anymote::messages::ResponseMessage& response_message() const;
  inline ::anymote::messages::ResponseMessage* mutable_response_message();
  inline ::anymote::messages::ResponseMessage* release_response_message();
  inline void set_allocated_response_message(::anymote::messages::ResponseMessage* response_message);

  // @@protoc_insertion_point(class_scope:anymote.messages.RemoteMessage)
 private:
  inline void set_has_sequence_number();
  inline void clear_has_sequence_number();
  inline void set_has_request_message();
  inline void clear_has_request_message();
  inline void set_has_response_message();
  inline void clear_has_response_message();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::anymote::messages::RequestMessage* request_message_;
  ::anymote::messages::ResponseMessage* response_message_;
  ::google::protobuf::uint32 sequence_number_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_remote_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_remote_2eproto();
  #endif
  friend void protobuf_AssignDesc_remote_2eproto();
  friend void protobuf_ShutdownFile_remote_2eproto();

  void InitAsDefaultInstance();
  static RemoteMessage* default_instance_;
};
// -------------------------------------------------------------------

class RequestMessage : public ::google::protobuf::MessageLite {
 public:
  RequestMessage();
  virtual ~RequestMessage();

  RequestMessage(const RequestMessage& from);

  inline RequestMessage& operator=(const RequestMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestMessage* other);

  // implements Message ----------------------------------------------

  RequestMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestMessage& from);
  void MergeFrom(const RequestMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .anymote.messages.KeyEvent key_event_message = 1;
  inline bool has_key_event_message() const;
  inline void clear_key_event_message();
  static const int kKeyEventMessageFieldNumber = 1;
  inline const ::anymote::messages::KeyEvent& key_event_message() const;
  inline ::anymote::messages::KeyEvent* mutable_key_event_message();
  inline ::anymote::messages::KeyEvent* release_key_event_message();
  inline void set_allocated_key_event_message(::anymote::messages::KeyEvent* key_event_message);

  // optional .anymote.messages.MouseEvent mouse_event_message = 2;
  inline bool has_mouse_event_message() const;
  inline void clear_mouse_event_message();
  static const int kMouseEventMessageFieldNumber = 2;
  inline const ::anymote::messages::MouseEvent& mouse_event_message() const;
  inline ::anymote::messages::MouseEvent* mutable_mouse_event_message();
  inline ::anymote::messages::MouseEvent* release_mouse_event_message();
  inline void set_allocated_mouse_event_message(::anymote::messages::MouseEvent* mouse_event_message);

  // optional .anymote.messages.MouseWheel mouse_wheel_message = 3;
  inline bool has_mouse_wheel_message() const;
  inline void clear_mouse_wheel_message();
  static const int kMouseWheelMessageFieldNumber = 3;
  inline const ::anymote::messages::MouseWheel& mouse_wheel_message() const;
  inline ::anymote::messages::MouseWheel* mutable_mouse_wheel_message();
  inline ::anymote::messages::MouseWheel* release_mouse_wheel_message();
  inline void set_allocated_mouse_wheel_message(::anymote::messages::MouseWheel* mouse_wheel_message);

  // optional .anymote.messages.Data data_message = 4;
  inline bool has_data_message() const;
  inline void clear_data_message();
  static const int kDataMessageFieldNumber = 4;
  inline const ::anymote::messages::Data& data_message() const;
  inline ::anymote::messages::Data* mutable_data_message();
  inline ::anymote::messages::Data* release_data_message();
  inline void set_allocated_data_message(::anymote::messages::Data* data_message);

  // optional .anymote.messages.Connect connect_message = 5;
  inline bool has_connect_message() const;
  inline void clear_connect_message();
  static const int kConnectMessageFieldNumber = 5;
  inline const ::anymote::messages::Connect& connect_message() const;
  inline ::anymote::messages::Connect* mutable_connect_message();
  inline ::anymote::messages::Connect* release_connect_message();
  inline void set_allocated_connect_message(::anymote::messages::Connect* connect_message);

  // optional .anymote.messages.Fling fling_message = 6;
  inline bool has_fling_message() const;
  inline void clear_fling_message();
  static const int kFlingMessageFieldNumber = 6;
  inline const ::anymote::messages::Fling& fling_message() const;
  inline ::anymote::messages::Fling* mutable_fling_message();
  inline ::anymote::messages::Fling* release_fling_message();
  inline void set_allocated_fling_message(::anymote::messages::Fling* fling_message);

  // @@protoc_insertion_point(class_scope:anymote.messages.RequestMessage)
 private:
  inline void set_has_key_event_message();
  inline void clear_has_key_event_message();
  inline void set_has_mouse_event_message();
  inline void clear_has_mouse_event_message();
  inline void set_has_mouse_wheel_message();
  inline void clear_has_mouse_wheel_message();
  inline void set_has_data_message();
  inline void clear_has_data_message();
  inline void set_has_connect_message();
  inline void clear_has_connect_message();
  inline void set_has_fling_message();
  inline void clear_has_fling_message();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::anymote::messages::KeyEvent* key_event_message_;
  ::anymote::messages::MouseEvent* mouse_event_message_;
  ::anymote::messages::MouseWheel* mouse_wheel_message_;
  ::anymote::messages::Data* data_message_;
  ::anymote::messages::Connect* connect_message_;
  ::anymote::messages::Fling* fling_message_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_remote_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_remote_2eproto();
  #endif
  friend void protobuf_AssignDesc_remote_2eproto();
  friend void protobuf_ShutdownFile_remote_2eproto();

  void InitAsDefaultInstance();
  static RequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class ResponseMessage : public ::google::protobuf::MessageLite {
 public:
  ResponseMessage();
  virtual ~ResponseMessage();

  ResponseMessage(const ResponseMessage& from);

  inline ResponseMessage& operator=(const ResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ResponseMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseMessage* other);

  // implements Message ----------------------------------------------

  ResponseMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseMessage& from);
  void MergeFrom(const ResponseMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .anymote.messages.Data data_message = 1;
  inline bool has_data_message() const;
  inline void clear_data_message();
  static const int kDataMessageFieldNumber = 1;
  inline const ::anymote::messages::Data& data_message() const;
  inline ::anymote::messages::Data* mutable_data_message();
  inline ::anymote::messages::Data* release_data_message();
  inline void set_allocated_data_message(::anymote::messages::Data* data_message);

  // optional .anymote.messages.FlingResult fling_result_message = 3;
  inline bool has_fling_result_message() const;
  inline void clear_fling_result_message();
  static const int kFlingResultMessageFieldNumber = 3;
  inline const ::anymote::messages::FlingResult& fling_result_message() const;
  inline ::anymote::messages::FlingResult* mutable_fling_result_message();
  inline ::anymote::messages::FlingResult* release_fling_result_message();
  inline void set_allocated_fling_result_message(::anymote::messages::FlingResult* fling_result_message);

  // @@protoc_insertion_point(class_scope:anymote.messages.ResponseMessage)
 private:
  inline void set_has_data_message();
  inline void clear_has_data_message();
  inline void set_has_fling_result_message();
  inline void clear_has_fling_result_message();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::anymote::messages::Data* data_message_;
  ::anymote::messages::FlingResult* fling_result_message_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_remote_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_remote_2eproto();
  #endif
  friend void protobuf_AssignDesc_remote_2eproto();
  friend void protobuf_ShutdownFile_remote_2eproto();

  void InitAsDefaultInstance();
  static ResponseMessage* default_instance_;
};
// -------------------------------------------------------------------

class KeyEvent : public ::google::protobuf::MessageLite {
 public:
  KeyEvent();
  virtual ~KeyEvent();

  KeyEvent(const KeyEvent& from);

  inline KeyEvent& operator=(const KeyEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const KeyEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const KeyEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(KeyEvent* other);

  // implements Message ----------------------------------------------

  KeyEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const KeyEvent& from);
  void MergeFrom(const KeyEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .anymote.messages.Code keycode = 1;
  inline bool has_keycode() const;
  inline void clear_keycode();
  static const int kKeycodeFieldNumber = 1;
  inline ::anymote::messages::Code keycode() const;
  inline void set_keycode(::anymote::messages::Code value);

  // required .anymote.messages.Action action = 2;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 2;
  inline ::anymote::messages::Action action() const;
  inline void set_action(::anymote::messages::Action value);

  // @@protoc_insertion_point(class_scope:anymote.messages.KeyEvent)
 private:
  inline void set_has_keycode();
  inline void clear_has_keycode();
  inline void set_has_action();
  inline void clear_has_action();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int keycode_;
  int action_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_remote_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_remote_2eproto();
  #endif
  friend void protobuf_AssignDesc_remote_2eproto();
  friend void protobuf_ShutdownFile_remote_2eproto();

  void InitAsDefaultInstance();
  static KeyEvent* default_instance_;
};
// -------------------------------------------------------------------

class MouseEvent : public ::google::protobuf::MessageLite {
 public:
  MouseEvent();
  virtual ~MouseEvent();

  MouseEvent(const MouseEvent& from);

  inline MouseEvent& operator=(const MouseEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MouseEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MouseEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MouseEvent* other);

  // implements Message ----------------------------------------------

  MouseEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MouseEvent& from);
  void MergeFrom(const MouseEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x_delta = 1;
  inline bool has_x_delta() const;
  inline void clear_x_delta();
  static const int kXDeltaFieldNumber = 1;
  inline ::google::protobuf::int32 x_delta() const;
  inline void set_x_delta(::google::protobuf::int32 value);

  // required int32 y_delta = 2;
  inline bool has_y_delta() const;
  inline void clear_y_delta();
  static const int kYDeltaFieldNumber = 2;
  inline ::google::protobuf::int32 y_delta() const;
  inline void set_y_delta(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:anymote.messages.MouseEvent)
 private:
  inline void set_has_x_delta();
  inline void clear_has_x_delta();
  inline void set_has_y_delta();
  inline void clear_has_y_delta();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 x_delta_;
  ::google::protobuf::int32 y_delta_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_remote_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_remote_2eproto();
  #endif
  friend void protobuf_AssignDesc_remote_2eproto();
  friend void protobuf_ShutdownFile_remote_2eproto();

  void InitAsDefaultInstance();
  static MouseEvent* default_instance_;
};
// -------------------------------------------------------------------

class MouseWheel : public ::google::protobuf::MessageLite {
 public:
  MouseWheel();
  virtual ~MouseWheel();

  MouseWheel(const MouseWheel& from);

  inline MouseWheel& operator=(const MouseWheel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MouseWheel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MouseWheel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MouseWheel* other);

  // implements Message ----------------------------------------------

  MouseWheel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MouseWheel& from);
  void MergeFrom(const MouseWheel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x_scroll = 1;
  inline bool has_x_scroll() const;
  inline void clear_x_scroll();
  static const int kXScrollFieldNumber = 1;
  inline ::google::protobuf::int32 x_scroll() const;
  inline void set_x_scroll(::google::protobuf::int32 value);

  // required int32 y_scroll = 2;
  inline bool has_y_scroll() const;
  inline void clear_y_scroll();
  static const int kYScrollFieldNumber = 2;
  inline ::google::protobuf::int32 y_scroll() const;
  inline void set_y_scroll(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:anymote.messages.MouseWheel)
 private:
  inline void set_has_x_scroll();
  inline void clear_has_x_scroll();
  inline void set_has_y_scroll();
  inline void clear_has_y_scroll();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 x_scroll_;
  ::google::protobuf::int32 y_scroll_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_remote_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_remote_2eproto();
  #endif
  friend void protobuf_AssignDesc_remote_2eproto();
  friend void protobuf_ShutdownFile_remote_2eproto();

  void InitAsDefaultInstance();
  static MouseWheel* default_instance_;
};
// -------------------------------------------------------------------

class Connect : public ::google::protobuf::MessageLite {
 public:
  Connect();
  virtual ~Connect();

  Connect(const Connect& from);

  inline Connect& operator=(const Connect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Connect& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Connect* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Connect* other);

  // implements Message ----------------------------------------------

  Connect* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Connect& from);
  void MergeFrom(const Connect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string device_name = 1;
  inline bool has_device_name() const;
  inline void clear_device_name();
  static const int kDeviceNameFieldNumber = 1;
  inline const ::std::string& device_name() const;
  inline void set_device_name(const ::std::string& value);
  inline void set_device_name(const char* value);
  inline void set_device_name(const char* value, size_t size);
  inline ::std::string* mutable_device_name();
  inline ::std::string* release_device_name();
  inline void set_allocated_device_name(::std::string* device_name);

  // optional int32 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:anymote.messages.Connect)
 private:
  inline void set_has_device_name();
  inline void clear_has_device_name();
  inline void set_has_version();
  inline void clear_has_version();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* device_name_;
  ::google::protobuf::int32 version_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_remote_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_remote_2eproto();
  #endif
  friend void protobuf_AssignDesc_remote_2eproto();
  friend void protobuf_ShutdownFile_remote_2eproto();

  void InitAsDefaultInstance();
  static Connect* default_instance_;
};
// -------------------------------------------------------------------

class Fling : public ::google::protobuf::MessageLite {
 public:
  Fling();
  virtual ~Fling();

  Fling(const Fling& from);

  inline Fling& operator=(const Fling& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Fling& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Fling* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Fling* other);

  // implements Message ----------------------------------------------

  Fling* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Fling& from);
  void MergeFrom(const Fling& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uri = 1;
  inline bool has_uri() const;
  inline void clear_uri();
  static const int kUriFieldNumber = 1;
  inline const ::std::string& uri() const;
  inline void set_uri(const ::std::string& value);
  inline void set_uri(const char* value);
  inline void set_uri(const char* value, size_t size);
  inline ::std::string* mutable_uri();
  inline ::std::string* release_uri();
  inline void set_allocated_uri(::std::string* uri);

  // @@protoc_insertion_point(class_scope:anymote.messages.Fling)
 private:
  inline void set_has_uri();
  inline void clear_has_uri();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* uri_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_remote_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_remote_2eproto();
  #endif
  friend void protobuf_AssignDesc_remote_2eproto();
  friend void protobuf_ShutdownFile_remote_2eproto();

  void InitAsDefaultInstance();
  static Fling* default_instance_;
};
// -------------------------------------------------------------------

class Data : public ::google::protobuf::MessageLite {
 public:
  Data();
  virtual ~Data();

  Data(const Data& from);

  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Data& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Data* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Data* other);

  // implements Message ----------------------------------------------

  Data* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Data& from);
  void MergeFrom(const Data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required string data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:anymote.messages.Data)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* type_;
  ::std::string* data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_remote_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_remote_2eproto();
  #endif
  friend void protobuf_AssignDesc_remote_2eproto();
  friend void protobuf_ShutdownFile_remote_2eproto();

  void InitAsDefaultInstance();
  static Data* default_instance_;
};
// -------------------------------------------------------------------

class FlingResult : public ::google::protobuf::MessageLite {
 public:
  FlingResult();
  virtual ~FlingResult();

  FlingResult(const FlingResult& from);

  inline FlingResult& operator=(const FlingResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FlingResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FlingResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FlingResult* other);

  // implements Message ----------------------------------------------

  FlingResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FlingResult& from);
  void MergeFrom(const FlingResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef FlingResult_Result Result;
  static const Result SUCCESS = FlingResult_Result_SUCCESS;
  static const Result FAILURE = FlingResult_Result_FAILURE;
  static inline bool Result_IsValid(int value) {
    return FlingResult_Result_IsValid(value);
  }
  static const Result Result_MIN =
    FlingResult_Result_Result_MIN;
  static const Result Result_MAX =
    FlingResult_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    FlingResult_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .anymote.messages.FlingResult.Result result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::anymote::messages::FlingResult_Result result() const;
  inline void set_result(::anymote::messages::FlingResult_Result value);

  // @@protoc_insertion_point(class_scope:anymote.messages.FlingResult)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_remote_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_remote_2eproto();
  #endif
  friend void protobuf_AssignDesc_remote_2eproto();
  friend void protobuf_ShutdownFile_remote_2eproto();

  void InitAsDefaultInstance();
  static FlingResult* default_instance_;
};
// ===================================================================


// ===================================================================

// RemoteMessage

// optional uint32 sequence_number = 1;
inline bool RemoteMessage::has_sequence_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoteMessage::set_has_sequence_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoteMessage::clear_has_sequence_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoteMessage::clear_sequence_number() {
  sequence_number_ = 0u;
  clear_has_sequence_number();
}
inline ::google::protobuf::uint32 RemoteMessage::sequence_number() const {
  // @@protoc_insertion_point(field_get:anymote.messages.RemoteMessage.sequence_number)
  return sequence_number_;
}
inline void RemoteMessage::set_sequence_number(::google::protobuf::uint32 value) {
  set_has_sequence_number();
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:anymote.messages.RemoteMessage.sequence_number)
}

// optional .anymote.messages.RequestMessage request_message = 2;
inline bool RemoteMessage::has_request_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoteMessage::set_has_request_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoteMessage::clear_has_request_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoteMessage::clear_request_message() {
  if (request_message_ != NULL) request_message_->::anymote::messages::RequestMessage::Clear();
  clear_has_request_message();
}
inline const ::anymote::messages::RequestMessage& RemoteMessage::request_message() const {
  // @@protoc_insertion_point(field_get:anymote.messages.RemoteMessage.request_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return request_message_ != NULL ? *request_message_ : *default_instance().request_message_;
#else
  return request_message_ != NULL ? *request_message_ : *default_instance_->request_message_;
#endif
}
inline ::anymote::messages::RequestMessage* RemoteMessage::mutable_request_message() {
  set_has_request_message();
  if (request_message_ == NULL) request_message_ = new ::anymote::messages::RequestMessage;
  // @@protoc_insertion_point(field_mutable:anymote.messages.RemoteMessage.request_message)
  return request_message_;
}
inline ::anymote::messages::RequestMessage* RemoteMessage::release_request_message() {
  clear_has_request_message();
  ::anymote::messages::RequestMessage* temp = request_message_;
  request_message_ = NULL;
  return temp;
}
inline void RemoteMessage::set_allocated_request_message(::anymote::messages::RequestMessage* request_message) {
  delete request_message_;
  request_message_ = request_message;
  if (request_message) {
    set_has_request_message();
  } else {
    clear_has_request_message();
  }
  // @@protoc_insertion_point(field_set_allocated:anymote.messages.RemoteMessage.request_message)
}

// optional .anymote.messages.ResponseMessage response_message = 3;
inline bool RemoteMessage::has_response_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoteMessage::set_has_response_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RemoteMessage::clear_has_response_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RemoteMessage::clear_response_message() {
  if (response_message_ != NULL) response_message_->::anymote::messages::ResponseMessage::Clear();
  clear_has_response_message();
}
inline const ::anymote::messages::ResponseMessage& RemoteMessage::response_message() const {
  // @@protoc_insertion_point(field_get:anymote.messages.RemoteMessage.response_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return response_message_ != NULL ? *response_message_ : *default_instance().response_message_;
#else
  return response_message_ != NULL ? *response_message_ : *default_instance_->response_message_;
#endif
}
inline ::anymote::messages::ResponseMessage* RemoteMessage::mutable_response_message() {
  set_has_response_message();
  if (response_message_ == NULL) response_message_ = new ::anymote::messages::ResponseMessage;
  // @@protoc_insertion_point(field_mutable:anymote.messages.RemoteMessage.response_message)
  return response_message_;
}
inline ::anymote::messages::ResponseMessage* RemoteMessage::release_response_message() {
  clear_has_response_message();
  ::anymote::messages::ResponseMessage* temp = response_message_;
  response_message_ = NULL;
  return temp;
}
inline void RemoteMessage::set_allocated_response_message(::anymote::messages::ResponseMessage* response_message) {
  delete response_message_;
  response_message_ = response_message;
  if (response_message) {
    set_has_response_message();
  } else {
    clear_has_response_message();
  }
  // @@protoc_insertion_point(field_set_allocated:anymote.messages.RemoteMessage.response_message)
}

// -------------------------------------------------------------------

// RequestMessage

// optional .anymote.messages.KeyEvent key_event_message = 1;
inline bool RequestMessage::has_key_event_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestMessage::set_has_key_event_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestMessage::clear_has_key_event_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestMessage::clear_key_event_message() {
  if (key_event_message_ != NULL) key_event_message_->::anymote::messages::KeyEvent::Clear();
  clear_has_key_event_message();
}
inline const ::anymote::messages::KeyEvent& RequestMessage::key_event_message() const {
  // @@protoc_insertion_point(field_get:anymote.messages.RequestMessage.key_event_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return key_event_message_ != NULL ? *key_event_message_ : *default_instance().key_event_message_;
#else
  return key_event_message_ != NULL ? *key_event_message_ : *default_instance_->key_event_message_;
#endif
}
inline ::anymote::messages::KeyEvent* RequestMessage::mutable_key_event_message() {
  set_has_key_event_message();
  if (key_event_message_ == NULL) key_event_message_ = new ::anymote::messages::KeyEvent;
  // @@protoc_insertion_point(field_mutable:anymote.messages.RequestMessage.key_event_message)
  return key_event_message_;
}
inline ::anymote::messages::KeyEvent* RequestMessage::release_key_event_message() {
  clear_has_key_event_message();
  ::anymote::messages::KeyEvent* temp = key_event_message_;
  key_event_message_ = NULL;
  return temp;
}
inline void RequestMessage::set_allocated_key_event_message(::anymote::messages::KeyEvent* key_event_message) {
  delete key_event_message_;
  key_event_message_ = key_event_message;
  if (key_event_message) {
    set_has_key_event_message();
  } else {
    clear_has_key_event_message();
  }
  // @@protoc_insertion_point(field_set_allocated:anymote.messages.RequestMessage.key_event_message)
}

// optional .anymote.messages.MouseEvent mouse_event_message = 2;
inline bool RequestMessage::has_mouse_event_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestMessage::set_has_mouse_event_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestMessage::clear_has_mouse_event_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestMessage::clear_mouse_event_message() {
  if (mouse_event_message_ != NULL) mouse_event_message_->::anymote::messages::MouseEvent::Clear();
  clear_has_mouse_event_message();
}
inline const ::anymote::messages::MouseEvent& RequestMessage::mouse_event_message() const {
  // @@protoc_insertion_point(field_get:anymote.messages.RequestMessage.mouse_event_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return mouse_event_message_ != NULL ? *mouse_event_message_ : *default_instance().mouse_event_message_;
#else
  return mouse_event_message_ != NULL ? *mouse_event_message_ : *default_instance_->mouse_event_message_;
#endif
}
inline ::anymote::messages::MouseEvent* RequestMessage::mutable_mouse_event_message() {
  set_has_mouse_event_message();
  if (mouse_event_message_ == NULL) mouse_event_message_ = new ::anymote::messages::MouseEvent;
  // @@protoc_insertion_point(field_mutable:anymote.messages.RequestMessage.mouse_event_message)
  return mouse_event_message_;
}
inline ::anymote::messages::MouseEvent* RequestMessage::release_mouse_event_message() {
  clear_has_mouse_event_message();
  ::anymote::messages::MouseEvent* temp = mouse_event_message_;
  mouse_event_message_ = NULL;
  return temp;
}
inline void RequestMessage::set_allocated_mouse_event_message(::anymote::messages::MouseEvent* mouse_event_message) {
  delete mouse_event_message_;
  mouse_event_message_ = mouse_event_message;
  if (mouse_event_message) {
    set_has_mouse_event_message();
  } else {
    clear_has_mouse_event_message();
  }
  // @@protoc_insertion_point(field_set_allocated:anymote.messages.RequestMessage.mouse_event_message)
}

// optional .anymote.messages.MouseWheel mouse_wheel_message = 3;
inline bool RequestMessage::has_mouse_wheel_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestMessage::set_has_mouse_wheel_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestMessage::clear_has_mouse_wheel_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestMessage::clear_mouse_wheel_message() {
  if (mouse_wheel_message_ != NULL) mouse_wheel_message_->::anymote::messages::MouseWheel::Clear();
  clear_has_mouse_wheel_message();
}
inline const ::anymote::messages::MouseWheel& RequestMessage::mouse_wheel_message() const {
  // @@protoc_insertion_point(field_get:anymote.messages.RequestMessage.mouse_wheel_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return mouse_wheel_message_ != NULL ? *mouse_wheel_message_ : *default_instance().mouse_wheel_message_;
#else
  return mouse_wheel_message_ != NULL ? *mouse_wheel_message_ : *default_instance_->mouse_wheel_message_;
#endif
}
inline ::anymote::messages::MouseWheel* RequestMessage::mutable_mouse_wheel_message() {
  set_has_mouse_wheel_message();
  if (mouse_wheel_message_ == NULL) mouse_wheel_message_ = new ::anymote::messages::MouseWheel;
  // @@protoc_insertion_point(field_mutable:anymote.messages.RequestMessage.mouse_wheel_message)
  return mouse_wheel_message_;
}
inline ::anymote::messages::MouseWheel* RequestMessage::release_mouse_wheel_message() {
  clear_has_mouse_wheel_message();
  ::anymote::messages::MouseWheel* temp = mouse_wheel_message_;
  mouse_wheel_message_ = NULL;
  return temp;
}
inline void RequestMessage::set_allocated_mouse_wheel_message(::anymote::messages::MouseWheel* mouse_wheel_message) {
  delete mouse_wheel_message_;
  mouse_wheel_message_ = mouse_wheel_message;
  if (mouse_wheel_message) {
    set_has_mouse_wheel_message();
  } else {
    clear_has_mouse_wheel_message();
  }
  // @@protoc_insertion_point(field_set_allocated:anymote.messages.RequestMessage.mouse_wheel_message)
}

// optional .anymote.messages.Data data_message = 4;
inline bool RequestMessage::has_data_message() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestMessage::set_has_data_message() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestMessage::clear_has_data_message() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestMessage::clear_data_message() {
  if (data_message_ != NULL) data_message_->::anymote::messages::Data::Clear();
  clear_has_data_message();
}
inline const ::anymote::messages::Data& RequestMessage::data_message() const {
  // @@protoc_insertion_point(field_get:anymote.messages.RequestMessage.data_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return data_message_ != NULL ? *data_message_ : *default_instance().data_message_;
#else
  return data_message_ != NULL ? *data_message_ : *default_instance_->data_message_;
#endif
}
inline ::anymote::messages::Data* RequestMessage::mutable_data_message() {
  set_has_data_message();
  if (data_message_ == NULL) data_message_ = new ::anymote::messages::Data;
  // @@protoc_insertion_point(field_mutable:anymote.messages.RequestMessage.data_message)
  return data_message_;
}
inline ::anymote::messages::Data* RequestMessage::release_data_message() {
  clear_has_data_message();
  ::anymote::messages::Data* temp = data_message_;
  data_message_ = NULL;
  return temp;
}
inline void RequestMessage::set_allocated_data_message(::anymote::messages::Data* data_message) {
  delete data_message_;
  data_message_ = data_message;
  if (data_message) {
    set_has_data_message();
  } else {
    clear_has_data_message();
  }
  // @@protoc_insertion_point(field_set_allocated:anymote.messages.RequestMessage.data_message)
}

// optional .anymote.messages.Connect connect_message = 5;
inline bool RequestMessage::has_connect_message() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestMessage::set_has_connect_message() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestMessage::clear_has_connect_message() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestMessage::clear_connect_message() {
  if (connect_message_ != NULL) connect_message_->::anymote::messages::Connect::Clear();
  clear_has_connect_message();
}
inline const ::anymote::messages::Connect& RequestMessage::connect_message() const {
  // @@protoc_insertion_point(field_get:anymote.messages.RequestMessage.connect_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return connect_message_ != NULL ? *connect_message_ : *default_instance().connect_message_;
#else
  return connect_message_ != NULL ? *connect_message_ : *default_instance_->connect_message_;
#endif
}
inline ::anymote::messages::Connect* RequestMessage::mutable_connect_message() {
  set_has_connect_message();
  if (connect_message_ == NULL) connect_message_ = new ::anymote::messages::Connect;
  // @@protoc_insertion_point(field_mutable:anymote.messages.RequestMessage.connect_message)
  return connect_message_;
}
inline ::anymote::messages::Connect* RequestMessage::release_connect_message() {
  clear_has_connect_message();
  ::anymote::messages::Connect* temp = connect_message_;
  connect_message_ = NULL;
  return temp;
}
inline void RequestMessage::set_allocated_connect_message(::anymote::messages::Connect* connect_message) {
  delete connect_message_;
  connect_message_ = connect_message;
  if (connect_message) {
    set_has_connect_message();
  } else {
    clear_has_connect_message();
  }
  // @@protoc_insertion_point(field_set_allocated:anymote.messages.RequestMessage.connect_message)
}

// optional .anymote.messages.Fling fling_message = 6;
inline bool RequestMessage::has_fling_message() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestMessage::set_has_fling_message() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestMessage::clear_has_fling_message() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestMessage::clear_fling_message() {
  if (fling_message_ != NULL) fling_message_->::anymote::messages::Fling::Clear();
  clear_has_fling_message();
}
inline const ::anymote::messages::Fling& RequestMessage::fling_message() const {
  // @@protoc_insertion_point(field_get:anymote.messages.RequestMessage.fling_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fling_message_ != NULL ? *fling_message_ : *default_instance().fling_message_;
#else
  return fling_message_ != NULL ? *fling_message_ : *default_instance_->fling_message_;
#endif
}
inline ::anymote::messages::Fling* RequestMessage::mutable_fling_message() {
  set_has_fling_message();
  if (fling_message_ == NULL) fling_message_ = new ::anymote::messages::Fling;
  // @@protoc_insertion_point(field_mutable:anymote.messages.RequestMessage.fling_message)
  return fling_message_;
}
inline ::anymote::messages::Fling* RequestMessage::release_fling_message() {
  clear_has_fling_message();
  ::anymote::messages::Fling* temp = fling_message_;
  fling_message_ = NULL;
  return temp;
}
inline void RequestMessage::set_allocated_fling_message(::anymote::messages::Fling* fling_message) {
  delete fling_message_;
  fling_message_ = fling_message;
  if (fling_message) {
    set_has_fling_message();
  } else {
    clear_has_fling_message();
  }
  // @@protoc_insertion_point(field_set_allocated:anymote.messages.RequestMessage.fling_message)
}

// -------------------------------------------------------------------

// ResponseMessage

// optional .anymote.messages.Data data_message = 1;
inline bool ResponseMessage::has_data_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseMessage::set_has_data_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseMessage::clear_has_data_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseMessage::clear_data_message() {
  if (data_message_ != NULL) data_message_->::anymote::messages::Data::Clear();
  clear_has_data_message();
}
inline const ::anymote::messages::Data& ResponseMessage::data_message() const {
  // @@protoc_insertion_point(field_get:anymote.messages.ResponseMessage.data_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return data_message_ != NULL ? *data_message_ : *default_instance().data_message_;
#else
  return data_message_ != NULL ? *data_message_ : *default_instance_->data_message_;
#endif
}
inline ::anymote::messages::Data* ResponseMessage::mutable_data_message() {
  set_has_data_message();
  if (data_message_ == NULL) data_message_ = new ::anymote::messages::Data;
  // @@protoc_insertion_point(field_mutable:anymote.messages.ResponseMessage.data_message)
  return data_message_;
}
inline ::anymote::messages::Data* ResponseMessage::release_data_message() {
  clear_has_data_message();
  ::anymote::messages::Data* temp = data_message_;
  data_message_ = NULL;
  return temp;
}
inline void ResponseMessage::set_allocated_data_message(::anymote::messages::Data* data_message) {
  delete data_message_;
  data_message_ = data_message;
  if (data_message) {
    set_has_data_message();
  } else {
    clear_has_data_message();
  }
  // @@protoc_insertion_point(field_set_allocated:anymote.messages.ResponseMessage.data_message)
}

// optional .anymote.messages.FlingResult fling_result_message = 3;
inline bool ResponseMessage::has_fling_result_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseMessage::set_has_fling_result_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseMessage::clear_has_fling_result_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseMessage::clear_fling_result_message() {
  if (fling_result_message_ != NULL) fling_result_message_->::anymote::messages::FlingResult::Clear();
  clear_has_fling_result_message();
}
inline const ::anymote::messages::FlingResult& ResponseMessage::fling_result_message() const {
  // @@protoc_insertion_point(field_get:anymote.messages.ResponseMessage.fling_result_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fling_result_message_ != NULL ? *fling_result_message_ : *default_instance().fling_result_message_;
#else
  return fling_result_message_ != NULL ? *fling_result_message_ : *default_instance_->fling_result_message_;
#endif
}
inline ::anymote::messages::FlingResult* ResponseMessage::mutable_fling_result_message() {
  set_has_fling_result_message();
  if (fling_result_message_ == NULL) fling_result_message_ = new ::anymote::messages::FlingResult;
  // @@protoc_insertion_point(field_mutable:anymote.messages.ResponseMessage.fling_result_message)
  return fling_result_message_;
}
inline ::anymote::messages::FlingResult* ResponseMessage::release_fling_result_message() {
  clear_has_fling_result_message();
  ::anymote::messages::FlingResult* temp = fling_result_message_;
  fling_result_message_ = NULL;
  return temp;
}
inline void ResponseMessage::set_allocated_fling_result_message(::anymote::messages::FlingResult* fling_result_message) {
  delete fling_result_message_;
  fling_result_message_ = fling_result_message;
  if (fling_result_message) {
    set_has_fling_result_message();
  } else {
    clear_has_fling_result_message();
  }
  // @@protoc_insertion_point(field_set_allocated:anymote.messages.ResponseMessage.fling_result_message)
}

// -------------------------------------------------------------------

// KeyEvent

// required .anymote.messages.Code keycode = 1;
inline bool KeyEvent::has_keycode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyEvent::set_has_keycode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyEvent::clear_has_keycode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyEvent::clear_keycode() {
  keycode_ = 0;
  clear_has_keycode();
}
inline ::anymote::messages::Code KeyEvent::keycode() const {
  // @@protoc_insertion_point(field_get:anymote.messages.KeyEvent.keycode)
  return static_cast< ::anymote::messages::Code >(keycode_);
}
inline void KeyEvent::set_keycode(::anymote::messages::Code value) {
  assert(::anymote::messages::Code_IsValid(value));
  set_has_keycode();
  keycode_ = value;
  // @@protoc_insertion_point(field_set:anymote.messages.KeyEvent.keycode)
}

// required .anymote.messages.Action action = 2;
inline bool KeyEvent::has_action() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyEvent::set_has_action() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyEvent::clear_has_action() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyEvent::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::anymote::messages::Action KeyEvent::action() const {
  // @@protoc_insertion_point(field_get:anymote.messages.KeyEvent.action)
  return static_cast< ::anymote::messages::Action >(action_);
}
inline void KeyEvent::set_action(::anymote::messages::Action value) {
  assert(::anymote::messages::Action_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:anymote.messages.KeyEvent.action)
}

// -------------------------------------------------------------------

// MouseEvent

// required int32 x_delta = 1;
inline bool MouseEvent::has_x_delta() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MouseEvent::set_has_x_delta() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MouseEvent::clear_has_x_delta() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MouseEvent::clear_x_delta() {
  x_delta_ = 0;
  clear_has_x_delta();
}
inline ::google::protobuf::int32 MouseEvent::x_delta() const {
  // @@protoc_insertion_point(field_get:anymote.messages.MouseEvent.x_delta)
  return x_delta_;
}
inline void MouseEvent::set_x_delta(::google::protobuf::int32 value) {
  set_has_x_delta();
  x_delta_ = value;
  // @@protoc_insertion_point(field_set:anymote.messages.MouseEvent.x_delta)
}

// required int32 y_delta = 2;
inline bool MouseEvent::has_y_delta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MouseEvent::set_has_y_delta() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MouseEvent::clear_has_y_delta() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MouseEvent::clear_y_delta() {
  y_delta_ = 0;
  clear_has_y_delta();
}
inline ::google::protobuf::int32 MouseEvent::y_delta() const {
  // @@protoc_insertion_point(field_get:anymote.messages.MouseEvent.y_delta)
  return y_delta_;
}
inline void MouseEvent::set_y_delta(::google::protobuf::int32 value) {
  set_has_y_delta();
  y_delta_ = value;
  // @@protoc_insertion_point(field_set:anymote.messages.MouseEvent.y_delta)
}

// -------------------------------------------------------------------

// MouseWheel

// required int32 x_scroll = 1;
inline bool MouseWheel::has_x_scroll() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MouseWheel::set_has_x_scroll() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MouseWheel::clear_has_x_scroll() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MouseWheel::clear_x_scroll() {
  x_scroll_ = 0;
  clear_has_x_scroll();
}
inline ::google::protobuf::int32 MouseWheel::x_scroll() const {
  // @@protoc_insertion_point(field_get:anymote.messages.MouseWheel.x_scroll)
  return x_scroll_;
}
inline void MouseWheel::set_x_scroll(::google::protobuf::int32 value) {
  set_has_x_scroll();
  x_scroll_ = value;
  // @@protoc_insertion_point(field_set:anymote.messages.MouseWheel.x_scroll)
}

// required int32 y_scroll = 2;
inline bool MouseWheel::has_y_scroll() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MouseWheel::set_has_y_scroll() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MouseWheel::clear_has_y_scroll() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MouseWheel::clear_y_scroll() {
  y_scroll_ = 0;
  clear_has_y_scroll();
}
inline ::google::protobuf::int32 MouseWheel::y_scroll() const {
  // @@protoc_insertion_point(field_get:anymote.messages.MouseWheel.y_scroll)
  return y_scroll_;
}
inline void MouseWheel::set_y_scroll(::google::protobuf::int32 value) {
  set_has_y_scroll();
  y_scroll_ = value;
  // @@protoc_insertion_point(field_set:anymote.messages.MouseWheel.y_scroll)
}

// -------------------------------------------------------------------

// Connect

// required string device_name = 1;
inline bool Connect::has_device_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Connect::set_has_device_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Connect::clear_has_device_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Connect::clear_device_name() {
  if (device_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_name_->clear();
  }
  clear_has_device_name();
}
inline const ::std::string& Connect::device_name() const {
  // @@protoc_insertion_point(field_get:anymote.messages.Connect.device_name)
  return *device_name_;
}
inline void Connect::set_device_name(const ::std::string& value) {
  set_has_device_name();
  if (device_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_name_ = new ::std::string;
  }
  device_name_->assign(value);
  // @@protoc_insertion_point(field_set:anymote.messages.Connect.device_name)
}
inline void Connect::set_device_name(const char* value) {
  set_has_device_name();
  if (device_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_name_ = new ::std::string;
  }
  device_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:anymote.messages.Connect.device_name)
}
inline void Connect::set_device_name(const char* value, size_t size) {
  set_has_device_name();
  if (device_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_name_ = new ::std::string;
  }
  device_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:anymote.messages.Connect.device_name)
}
inline ::std::string* Connect::mutable_device_name() {
  set_has_device_name();
  if (device_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:anymote.messages.Connect.device_name)
  return device_name_;
}
inline ::std::string* Connect::release_device_name() {
  clear_has_device_name();
  if (device_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = device_name_;
    device_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Connect::set_allocated_device_name(::std::string* device_name) {
  if (device_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete device_name_;
  }
  if (device_name) {
    set_has_device_name();
    device_name_ = device_name;
  } else {
    clear_has_device_name();
    device_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:anymote.messages.Connect.device_name)
}

// optional int32 version = 2;
inline bool Connect::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Connect::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Connect::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Connect::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 Connect::version() const {
  // @@protoc_insertion_point(field_get:anymote.messages.Connect.version)
  return version_;
}
inline void Connect::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:anymote.messages.Connect.version)
}

// -------------------------------------------------------------------

// Fling

// required string uri = 1;
inline bool Fling::has_uri() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fling::set_has_uri() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Fling::clear_has_uri() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Fling::clear_uri() {
  if (uri_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_->clear();
  }
  clear_has_uri();
}
inline const ::std::string& Fling::uri() const {
  // @@protoc_insertion_point(field_get:anymote.messages.Fling.uri)
  return *uri_;
}
inline void Fling::set_uri(const ::std::string& value) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
  // @@protoc_insertion_point(field_set:anymote.messages.Fling.uri)
}
inline void Fling::set_uri(const char* value) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
  // @@protoc_insertion_point(field_set_char:anymote.messages.Fling.uri)
}
inline void Fling::set_uri(const char* value, size_t size) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_ = new ::std::string;
  }
  uri_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:anymote.messages.Fling.uri)
}
inline ::std::string* Fling::mutable_uri() {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:anymote.messages.Fling.uri)
  return uri_;
}
inline ::std::string* Fling::release_uri() {
  clear_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = uri_;
    uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Fling::set_allocated_uri(::std::string* uri) {
  if (uri_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uri_;
  }
  if (uri) {
    set_has_uri();
    uri_ = uri;
  } else {
    clear_has_uri();
    uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:anymote.messages.Fling.uri)
}

// -------------------------------------------------------------------

// Data

// required string type = 1;
inline bool Data::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Data::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Data::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Data::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& Data::type() const {
  // @@protoc_insertion_point(field_get:anymote.messages.Data.type)
  return *type_;
}
inline void Data::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:anymote.messages.Data.type)
}
inline void Data::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:anymote.messages.Data.type)
}
inline void Data::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:anymote.messages.Data.type)
}
inline ::std::string* Data::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:anymote.messages.Data.type)
  return type_;
}
inline ::std::string* Data::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Data::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:anymote.messages.Data.type)
}

// required string data = 2;
inline bool Data::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Data::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Data::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Data::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Data::data() const {
  // @@protoc_insertion_point(field_get:anymote.messages.Data.data)
  return *data_;
}
inline void Data::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:anymote.messages.Data.data)
}
inline void Data::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:anymote.messages.Data.data)
}
inline void Data::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:anymote.messages.Data.data)
}
inline ::std::string* Data::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:anymote.messages.Data.data)
  return data_;
}
inline ::std::string* Data::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Data::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:anymote.messages.Data.data)
}

// -------------------------------------------------------------------

// FlingResult

// required .anymote.messages.FlingResult.Result result = 1;
inline bool FlingResult::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlingResult::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlingResult::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlingResult::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::anymote::messages::FlingResult_Result FlingResult::result() const {
  // @@protoc_insertion_point(field_get:anymote.messages.FlingResult.result)
  return static_cast< ::anymote::messages::FlingResult_Result >(result_);
}
inline void FlingResult::set_result(::anymote::messages::FlingResult_Result value) {
  assert(::anymote::messages::FlingResult_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:anymote.messages.FlingResult.result)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace messages
}  // namespace anymote

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_remote_2eproto__INCLUDED
